{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.10.15", "generated_at": "2025-12-31T15:33:59.508577Z", "invocation_id": "e9cb28df-a9d2-4e8a-8459-8a5cd77ce05b", "invocation_started_at": "2025-12-31T15:33:54.498999Z", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-31T15:33:58.322490Z", "completed_at": "2025-12-31T15:33:58.397808Z"}, {"name": "execute", "started_at": "2025-12-31T15:33:58.427180Z", "completed_at": "2025-12-31T15:33:59.027107Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.7353556156158447, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_refunds", "compiled": true, "compiled_code": "-- int_unified_refunds.sql\n-- PURPOSE: Combine refunds from ALL chains into ONE table with converted amounts\n-- WHY: Refunds = capital returning to relayers. Tracks when relayers get paid back.\n\n\n\n-- Token metadata for amount conversion\nWITH token_meta AS (\n    \n    SELECT \n        LOWER(token_address) AS token_address,\n        token_symbol,\n        decimals,\n        chain_id\n    FROM \"across_analytics\".\"dbt\".\"token_metadata\"\n\n),\n\n-- Chain ID to Name mapping for chains with parquet data\nchain_names AS (\n    SELECT chain_id, chain_name\n    FROM (\n        VALUES\n        (1, 'Ethereum'), (42161, 'Arbitrum'), (137, 'Polygon'),\n        (59144, 'Linea'), (480, 'Worldchain'), (130, 'Unichain'),\n        (999, 'HyperEVM'), (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Each CTE selects from a chain's staging model\narbitrum_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'arbitrum' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_arbitrum__refunds\"\n),\n\nethereum_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'ethereum' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_ethereum__refunds\"\n),\n\npolygon_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'polygon' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_polygon__refunds\"\n),\n\nlinea_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'linea' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_linea__refunds\"\n),\n\nworldchain_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'worldchain' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_worldchain__refunds\"\n),\n\nunichain_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'unichain' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_unichain__refunds\"\n),\n\nhyperevm_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'hyperevm' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_hyperevm__refunds\"\n),\n\nmonad_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'monad' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_monad__refunds\"\n),\n\n-- UNION ALL: Stack all refunds from all chains\nall_refunds AS (\n    SELECT * FROM arbitrum_refunds\n    UNION ALL\n    SELECT * FROM ethereum_refunds\n    UNION ALL\n    SELECT * FROM polygon_refunds\n    UNION ALL\n    SELECT * FROM linea_refunds\n    UNION ALL\n    SELECT * FROM worldchain_refunds\n    UNION ALL\n    SELECT * FROM unichain_refunds\n    UNION ALL\n    SELECT * FROM hyperevm_refunds\n    UNION ALL\n    SELECT * FROM monad_refunds\n)\n\n-- Final SELECT: Join with token metadata and convert amounts\nSELECT\n    r.refund_timestamp,\n    r.transaction_hash,\n    r.chain_id,\n    cn.chain_name,\n    r.root_bundle_id,\n    r.leaf_id,\n    r.refund_token_address,\n    tok.token_symbol AS refund_token_symbol,\n    tok.decimals AS token_decimals,\n    -- Rescaled amount (human-readable)\n    \n    r.total_refund_amount_raw / POWER(10, COALESCE(tok.decimals, 18))\n AS total_refund_amount,\n    -- Raw amount (preserved for auditing)\n    r.total_refund_amount_raw,\n    r.refund_addresses_string,\n    r.refund_amounts_string,\n    r.refund_count,\n    r.source_blockchain\n\nFROM all_refunds r\n\n-- Join for chain name\nLEFT JOIN chain_names cn ON r.chain_id = cn.chain_id\n\n-- Join with token metadata on address + chain_id\nLEFT JOIN token_meta AS tok\n    ON r.refund_token_address = tok.token_address\n    AND r.chain_id = tok.chain_id", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_refunds\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-31T15:33:58.295573Z", "completed_at": "2025-12-31T15:33:58.359422Z"}, {"name": "execute", "started_at": "2025-12-31T15:33:58.362377Z", "completed_at": "2025-12-31T15:33:59.145741Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.8581335544586182, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_fills", "compiled": true, "compiled_code": "-- int_unified_fills.sql\n-- PURPOSE: Combine fills from ALL chains into ONE table\n-- WHY: Fills happen on the DESTINATION chain. We need to see all fills to match with deposits.\n\n\n\n-- Each CTE selects from a chain's staging model and adds the destination chain ID\nWITH arbitrum_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        42161 AS destination_chain_id,  -- Fill happened ON Arbitrum\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_arbitrum__fills\"\n),\n\nethereum_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        1 AS destination_chain_id,  -- Fill happened ON Ethereum\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_ethereum__fills\"\n),\n\npolygon_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        137 AS destination_chain_id,  -- Fill happened ON Polygon\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_polygon__fills\"\n),\n\nlinea_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        59144 AS destination_chain_id,  -- Fill happened ON Linea\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_linea__fills\"\n),\n\nworldchain_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        480 AS destination_chain_id,  -- Fill happened ON WorldChain\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_worldchain__fills\"\n),\n\nunichain_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        130 AS destination_chain_id,  -- Fill happened ON Unichain\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_unichain__fills\"\n),\n\nhyperevm_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        999 AS destination_chain_id,  -- Fill happened ON HyperEVM\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_hyperevm__fills\"\n),\n\nmonad_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        143 AS destination_chain_id,  -- Fill happened ON Monad\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_monad__fills\"\n),\n\n-- Supported chain IDs (chains we have parquet data for)\n-- 42161=Arbitrum, 1=Ethereum, 137=Polygon, 59144=Linea, 480=Worldchain, 130=Unichain, 999=HyperEVM, 143=Monad\n\n-- Chain ID to Name mapping for chains with parquet data\nchain_names AS (\n    SELECT chain_id, chain_name\n    FROM (\n        VALUES\n        (1, 'Ethereum'), (42161, 'Arbitrum'), (137, 'Polygon'),\n        (59144, 'Linea'), (480, 'Worldchain'), (130, 'Unichain'),\n        (999, 'HyperEVM'), (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Hourly token prices for USD conversion\ntoken_prices AS (\n    SELECT \n        token_symbol,\n        DATE_TRUNC('hour', timestamp::TIMESTAMP) AS price_hour,\n        AVG(price_usd) AS price_usd\n    FROM \"across_analytics\".\"dbt\".\"token_prices\"\n    GROUP BY token_symbol, DATE_TRUNC('hour', timestamp::TIMESTAMP)\n),\n\n-- UNION ALL: Stack all fills from all chains into one table\n-- Filter: Only include fills where origin_chain_id is a supported chain\nall_fills AS (\n    SELECT * FROM arbitrum_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM ethereum_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM polygon_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM linea_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM worldchain_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM unichain_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM hyperevm_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM monad_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n)\n\n-- Final SELECT with descriptive chain names and USD amounts\nSELECT\n    f.fill_timestamp,\n    f.transaction_hash,\n    f.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    f.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    f.deposit_id,\n    f.relayer_address,\n    f.depositor_address,\n    f.recipient_address,\n    f.input_token_address,\n    f.output_token_address,\n    f.output_token_symbol AS fill_token_symbol,  -- Token symbol for the filled amount\n    f.input_amount,\n    f.output_amount,\n    f.repayment_chain_id,\n    -- Gas data (for relayer cost analysis)\n    f.gas_price_wei,\n    f.gas_used,\n    f.gas_cost_wei,\n    -- USD price data\n    tp.price_usd AS output_token_price_usd,\n    ROUND((f.output_amount * COALESCE(tp.price_usd, 1))::NUMERIC, 2) AS output_amount_usd\nFROM all_fills f\nLEFT JOIN chain_names oc ON f.origin_chain_id = oc.chain_id\nLEFT JOIN chain_names dc ON f.destination_chain_id = dc.chain_id\n-- Join for output token price at fill hour\nLEFT JOIN token_prices tp\n    ON f.output_token_symbol = tp.token_symbol\n    AND DATE_TRUNC('hour', f.fill_timestamp) = tp.price_hour", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-31T15:33:58.341954Z", "completed_at": "2025-12-31T15:33:58.500964Z"}, {"name": "execute", "started_at": "2025-12-31T15:33:58.510621Z", "completed_at": "2025-12-31T15:33:59.162724Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.84303879737854, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_deposits", "compiled": true, "compiled_code": "-- int_unified_deposits.sql\n-- PURPOSE: Combine deposits from ALL chains into ONE table\n-- WHY: Right now deposits are separate per chain. We need them unified to track cross-chain flows.\n\n\n\n-- Each CTE selects from a chain's staging model and adds the origin chain ID\nWITH arbitrum_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        42161 AS origin_chain_id,  -- Arbitrum's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_arbitrum__deposits\"\n),\n\nethereum_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        1 AS origin_chain_id,  -- Ethereum's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_ethereum__deposits\"\n),\n\npolygon_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        137 AS origin_chain_id,  -- Polygon's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_polygon__deposits\"\n),\n\nlinea_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        59144 AS origin_chain_id,  -- Linea's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_linea__deposits\"\n),\n\nworldchain_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        480 AS origin_chain_id,  -- WorldChain's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_worldchain__deposits\"\n),\n\nunichain_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        130 AS origin_chain_id,  -- Unichain's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_unichain__deposits\"\n),\n\nhyperevm_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        999 AS origin_chain_id,  -- HyperEVM's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_hyperevm__deposits\"\n),\n\nmonad_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        143 AS origin_chain_id,  -- Monad's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_monad__deposits\"\n),\n\n-- Supported chain IDs (chains we have parquet data for)\n-- 42161=Arbitrum, 1=Ethereum, 137=Polygon, 59144=Linea, 480=Worldchain, 130=Unichain, 999=HyperEVM, 143=Monad\n\n-- Chain ID to Name mapping for chains with parquet data\nchain_names AS (\n    SELECT chain_id, chain_name\n    FROM (\n        VALUES\n        (1, 'Ethereum'), (42161, 'Arbitrum'), (137, 'Polygon'),\n        (59144, 'Linea'), (480, 'Worldchain'), (130, 'Unichain'),\n        (999, 'HyperEVM'), (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Hourly token prices for USD conversion\ntoken_prices AS (\n    SELECT \n        token_symbol,\n        DATE_TRUNC('hour', timestamp::TIMESTAMP) AS price_hour,\n        AVG(price_usd) AS price_usd\n    FROM \"across_analytics\".\"dbt\".\"token_prices\"\n    GROUP BY token_symbol, DATE_TRUNC('hour', timestamp::TIMESTAMP)\n),\n\n-- UNION ALL: Stack all deposits from all chains into one table\n-- Filter: Only include deposits where destination_chain_id is a supported chain\nall_deposits AS (\n    SELECT * FROM arbitrum_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM ethereum_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM polygon_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM linea_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM worldchain_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM unichain_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM hyperevm_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM monad_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n)\n\n-- Final SELECT with descriptive chain names and USD amounts\nSELECT\n    d.deposit_timestamp,\n    d.transaction_hash,\n    d.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    d.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    d.deposit_id,\n    d.depositor_address,\n    d.recipient_address,\n    d.input_token_address,\n    d.input_token_symbol,\n    d.output_token_address,\n    d.output_token_symbol,\n    d.input_amount,\n    d.output_amount,\n    -- USD price data\n    tp.price_usd AS input_token_price_usd,\n    ROUND((d.input_amount * COALESCE(tp.price_usd, 1))::NUMERIC, 2) AS input_amount_usd\nFROM all_deposits d\nLEFT JOIN chain_names oc ON d.origin_chain_id = oc.chain_id\nLEFT JOIN chain_names dc ON d.destination_chain_id = dc.chain_id\n-- Join for input token price at deposit hour\nLEFT JOIN token_prices tp\n    ON d.input_token_symbol = tp.token_symbol\n    AND DATE_TRUNC('hour', d.deposit_timestamp) = tp.price_hour", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_deposits\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-31T15:33:59.088498Z", "completed_at": "2025-12-31T15:33:59.113960Z"}, {"name": "execute", "started_at": "2025-12-31T15:33:59.117328Z", "completed_at": "2025-12-31T15:33:59.351518Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.2755014896392822, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_refunds_expanded", "compiled": true, "compiled_code": "-- int_refunds_expanded.sql\n-- CHALLENGE: some refund_amounts_string are arrays that have to be unnested\n-- PURPOSE: Expand comma-separated refund arrays into individual rows\n-- WHY: Each row = one relayer receiving one refund amount\n-- ENABLES: Easy aggregation, filtering by relayer, joins with relayer metrics\n\n\n\nWITH unified AS (\n    -- Get all refunds from all chains (already unified in int_unified_refunds)\n    SELECT * \n    FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_refunds\"\n    WHERE refund_count > 0  -- Only process batches with actual refunds\n),\n\n-- Hourly token prices for USD conversion\ntoken_prices AS (\n    SELECT \n        token_symbol,\n        DATE_TRUNC('hour', timestamp::TIMESTAMP) AS price_hour,\n        AVG(price_usd) AS price_usd\n    FROM \"across_analytics\".\"dbt\".\"token_prices\"\n    GROUP BY token_symbol, DATE_TRUNC('hour', timestamp::TIMESTAMP)\n),\n\n-- Unnest the comma-separated strings into individual rows\n-- Uses CROSS JOIN LATERAL with UNNEST to expand arrays\n-- WITH ORDINALITY gives us the position index for matching amounts to addresses\nexpanded AS (\n    SELECT\n        -- Batch-level identifiers (same for all rows from same batch)\n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        chain_name,\n        root_bundle_id,\n        leaf_id,\n        refund_token_address,\n        refund_token_symbol,\n        token_decimals,\n        total_refund_amount,\n        total_refund_amount_raw,\n        refund_count,\n        source_blockchain,\n        \n        -- Individual refund data (one row per relayer/amount pair)\n        -- TRIM handles any whitespace that might exist in the CSV-like strings\n        TRIM(amounts.amount)::NUMERIC AS refund_amount_raw,\n        TRIM(addresses.address) AS relayer_address,\n        amounts.idx AS refund_index\n        \n    FROM unified\n    -- Expand refund_amounts_string: \"100,200,300\" \u2192 3 rows with values 100, 200, 300\n    CROSS JOIN LATERAL UNNEST(\n        string_to_array(refund_amounts_string, ',')\n    ) WITH ORDINALITY AS amounts(amount, idx)\n    -- Expand refund_addresses_string: \"0xAAA,0xBBB,0xCCC\" \u2192 3 rows with addresses\n    CROSS JOIN LATERAL UNNEST(\n        string_to_array(refund_addresses_string, ',')\n    ) WITH ORDINALITY AS addresses(address, idx)\n    -- Match by position: 1st amount goes to 1st address, 2nd to 2nd, etc.\n    WHERE amounts.idx = addresses.idx\n)\n\nSELECT\n    -- Event identification\n    e.refund_timestamp,\n    e.transaction_hash,\n    e.source_blockchain,\n    \n    -- Batch identifiers (for grouping back if needed)\n    e.chain_id,\n    e.chain_name,\n    e.root_bundle_id,\n    e.leaf_id,\n    \n    -- Individual refund details\n    e.refund_index,\n    e.relayer_address,\n    e.refund_token_address,\n    e.refund_token_symbol,\n    \n    -- Individual refund amount (rescaled using token decimals)\n    \n    e.refund_amount_raw / POWER(10, COALESCE(e.token_decimals, 18))\n AS refund_amount,\n    e.refund_amount_raw,\n    \n    -- USD price data\n    tp.price_usd AS refund_token_price_usd,\n    ROUND((\n    e.refund_amount_raw / POWER(10, COALESCE(e.token_decimals, 18))\n * COALESCE(tp.price_usd, 1))::NUMERIC, 2) AS refund_amount_usd,\n    \n    -- Batch context (useful for analysis)\n    e.total_refund_amount AS batch_total_amount,\n    e.total_refund_amount_raw AS batch_total_amount_raw,\n    e.refund_count AS batch_refund_count,\n    \n    -- Unique identifier for each individual refund record\n    e.transaction_hash || '-' || e.leaf_id || '-' || e.refund_index AS refund_id\n    \nFROM expanded e\n-- Join for refund token price at refund hour\nLEFT JOIN token_prices tp\n    ON e.refund_token_symbol = tp.token_symbol\n    AND DATE_TRUNC('hour', e.refund_timestamp) = tp.price_hour", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_refunds_expanded\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-31T15:33:59.182744Z", "completed_at": "2025-12-31T15:33:59.200335Z"}, {"name": "execute", "started_at": "2025-12-31T15:33:59.201932Z", "completed_at": "2025-12-31T15:33:59.391154Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.21282410621643066, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_deposit_fill_matching", "compiled": true, "compiled_code": "-- int_deposit_fill_matching.sql\n-- PURPOSE: Match every deposit to its fill (if it exists)\n-- WHY: This is the CORE model - connects money leaving one chain to money arriving on another.\n-- \n-- HOW IT WORKS:\n-- 1. User deposits on Chain A \u2192 creates deposit_id\n-- 2. Relayer fills on Chain B \u2192 same deposit_id\n-- 3. We JOIN on deposit_id + origin/destination chain match\n-- 4. Unfilled deposits = rows with NULL fill (stuck capital)\n\n\n\n-- Chain ID to Name mapping for chains with parquet data\nWITH chain_names AS (\n    SELECT \n        chain_id,\n        chain_name\n    FROM (\n        VALUES\n        -- Only chains we have parquet data for:\n        (1, 'Ethereum'),\n        (42161, 'Arbitrum'),\n        (137, 'Polygon'),\n        (59144, 'Linea'),\n        (480, 'Worldchain'),\n        (130, 'Unichain'),\n        (999, 'HyperEVM'),\n        (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Token metadata for symbol lookups\ntoken_metadata AS (\n    SELECT * FROM \"across_analytics\".\"dbt\".\"token_metadata\"\n),\n\n-- Hourly token prices for USD conversion\n-- Truncate to hour for matching with transaction timestamps\ntoken_prices AS (\n    SELECT \n        token_symbol,\n        DATE_TRUNC('hour', timestamp::TIMESTAMP) AS price_hour,\n        AVG(price_usd) AS price_usd  -- Average in case of duplicate hours\n    FROM \"across_analytics\".\"dbt\".\"token_prices\"\n    GROUP BY token_symbol, DATE_TRUNC('hour', timestamp::TIMESTAMP)\n),\n\n-- Native token symbol per chain (for gas cost USD conversion)\n-- Gas fees are paid in the chain's native token\nnative_tokens AS (\n    SELECT chain_id, native_token_symbol\n    FROM (\n        VALUES\n        (1, 'WETH'),       -- Ethereum: ETH (use WETH price)\n        (42161, 'WETH'),   -- Arbitrum: ETH\n        (137, 'MATIC'),    -- Polygon: MATIC\n        (59144, 'WETH'),   -- Linea: ETH\n        (480, 'WETH'),     -- Worldchain: ETH (WLD for app, but gas in ETH)\n        (130, 'WETH'),     -- Unichain: ETH\n        (999, 'WETH'),     -- HyperEVM: ETH\n        (143, 'WETH')      -- Monad: ETH (assumed)\n    ) AS nt(chain_id, native_token_symbol)\n),\n\ndeposits AS (\n    SELECT * FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_deposits\"\n),\n\nfills AS (\n    SELECT * FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_fills\"\n),\n\n-- JOIN deposits to fills on deposit_id + chain matching\nmatched AS (\n    SELECT\n        -- === DEPOSIT INFO (Origin side) ===\n        d.deposit_timestamp,\n        d.transaction_hash AS deposit_tx_hash,\n        d.origin_chain_id,\n        d.destination_chain_id,\n        d.deposit_id,\n        d.depositor_address,\n        d.recipient_address AS deposit_recipient,\n        d.input_token_address AS deposit_token,\n        d.input_amount AS deposit_amount,\n        d.output_amount AS expected_output_amount,\n        \n        -- === FILL INFO (Destination side) ===\n        f.fill_timestamp,\n        f.transaction_hash AS fill_tx_hash,\n        f.relayer_address,\n        f.output_token_address AS fill_token,\n        f.output_amount AS actual_output_amount,\n        f.repayment_chain_id,\n        \n        -- === GAS DATA (for relayer cost analysis) ===\n        f.gas_price_wei,\n        f.gas_used,\n        f.gas_cost_wei,\n        \n        -- === COMPUTED FIELDS ===\n        -- Fill latency: How long did it take to fill? (in seconds)\n        -- Use GREATEST(0, ...) to handle cross-chain timestamp sync issues\n        GREATEST(0, EXTRACT(EPOCH FROM (f.fill_timestamp - d.deposit_timestamp))) AS fill_latency_seconds,\n        \n        -- Is this deposit filled?\n        CASE WHEN f.deposit_id IS NOT NULL THEN TRUE ELSE FALSE END AS is_filled,\n        \n        -- Fee: difference between deposited amount and filled amount\n        CASE \n            WHEN f.output_amount IS NOT NULL\n            THEN ROUND((d.input_amount - f.output_amount)::NUMERIC, 2)\n            ELSE NULL \n        END AS bridge_fee_nominal,\n        \n        CASE \n            WHEN f.output_amount IS NOT NULL\n            THEN ROUND(((d.input_amount - f.output_amount) / d.input_amount * 100)::NUMERIC, 2)\n            ELSE NULL \n        END AS bridge_fee_percent,\n        \n        -- Slippage: Difference between expected and actual output\n        CASE \n            WHEN f.output_amount IS NOT NULL AND d.output_amount > 0 \n            THEN ROUND(((d.output_amount - f.output_amount) / d.output_amount * 100)::NUMERIC, 2)\n            ELSE NULL \n        END AS slippage_percent\n\n    FROM deposits d\n    \n    -- LEFT JOIN: Keep ALL deposits, even unfilled ones\n    LEFT JOIN fills f \n        ON d.deposit_id = f.deposit_id\n        AND d.origin_chain_id = f.origin_chain_id  -- Must match origin\n        AND d.destination_chain_id = f.destination_chain_id  -- Must match destination\n)\n\nSELECT\n    -- Identity\n    m.deposit_timestamp,\n    m.deposit_tx_hash,\n    m.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    m.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    m.deposit_id,\n    \n    -- Deposit details\n    m.depositor_address,\n    m.deposit_recipient,\n    m.deposit_token,\n    dt.token_symbol AS deposit_token_symbol,\n    m.deposit_amount,\n    m.expected_output_amount,\n    \n    -- USD-normalized amounts (joined from hourly price data)\n    dp.price_usd AS deposit_token_price_usd,\n    ROUND((m.deposit_amount * COALESCE(dp.price_usd, 1))::NUMERIC, 2) AS deposit_amount_usd,\n    \n    -- Fill details (NULL if unfilled)\n    m.fill_timestamp,\n    m.fill_tx_hash,\n    m.relayer_address,\n    m.fill_token,\n    ft.token_symbol AS fill_token_symbol,\n    m.actual_output_amount,\n    m.repayment_chain_id,\n    \n    -- USD-normalized fill amount\n    fp.price_usd AS fill_token_price_usd,\n    CASE \n        WHEN m.actual_output_amount IS NOT NULL \n        THEN ROUND((m.actual_output_amount * COALESCE(fp.price_usd, 1))::NUMERIC, 2)\n        ELSE NULL \n    END AS fill_amount_usd,\n    \n    -- Metrics\n    m.fill_latency_seconds,\n    m.is_filled,\n    m.bridge_fee_nominal,\n    m.bridge_fee_percent,\n    m.slippage_percent,\n    \n    -- Gas data (for relayer cost analysis)\n    -- These represent the cost incurred by the relayer on the destination chain\n    -- NOTE: Different chains use different native tokens (ETH, MATIC, WLD, etc.)\n    m.gas_price_wei,\n    m.gas_used,\n    m.gas_cost_wei,\n    -- Convert gas cost to native token units for readability (wei / 10^18)\n    ROUND((m.gas_cost_wei / 1e18)::NUMERIC, 8) AS gas_cost_native,\n    -- Gas cost in USD (using native token price at fill hour)\n    CASE \n        WHEN m.gas_cost_wei IS NOT NULL \n        THEN ROUND(((m.gas_cost_wei / 1e18) * COALESCE(np.price_usd, 0))::NUMERIC, 2)\n        ELSE NULL \n    END AS gas_cost_usd,\n    \n    -- Bridge fee in USD (fee * deposit token price)\n    CASE \n        WHEN m.bridge_fee_nominal IS NOT NULL \n        THEN ROUND((m.bridge_fee_nominal * COALESCE(dp.price_usd, 1))::NUMERIC, 2)\n        ELSE NULL \n    END AS bridge_fee_nominal_usd,\n    \n    -- Route identifier (for aggregations)\n    oc.chain_name || ' \u2192 ' || dc.chain_name AS route_name,\n    m.origin_chain_id || '_' || m.destination_chain_id AS route_id\n\nFROM matched m\n\n-- Join for origin chain name\nLEFT JOIN chain_names oc ON m.origin_chain_id = oc.chain_id\n\n-- Join for destination chain name  \nLEFT JOIN chain_names dc ON m.destination_chain_id = dc.chain_id\n\n-- Join for deposit token symbol (origin chain token)\nLEFT JOIN token_metadata dt \n    ON m.origin_chain_id = dt.chain_id \n    AND LOWER(m.deposit_token) = LOWER(dt.token_address)\n\n-- Join for fill token symbol (destination chain token)\nLEFT JOIN token_metadata ft \n    ON m.destination_chain_id = ft.chain_id \n    AND LOWER(m.fill_token) = LOWER(ft.token_address)\n\n-- Join for deposit token price at deposit hour\nLEFT JOIN token_prices dp\n    ON dt.token_symbol = dp.token_symbol\n    AND DATE_TRUNC('hour', m.deposit_timestamp) = dp.price_hour\n\n-- Join for fill token price at fill hour\nLEFT JOIN token_prices fp\n    ON ft.token_symbol = fp.token_symbol\n    AND DATE_TRUNC('hour', m.fill_timestamp) = fp.price_hour\n\n-- Join for native token symbol on destination chain (for gas cost USD)\nLEFT JOIN native_tokens nt ON m.destination_chain_id = nt.chain_id\n\n-- Join for native token price at fill hour (for gas cost USD)\nLEFT JOIN token_prices np\n    ON nt.native_token_symbol = np.token_symbol\n    AND DATE_TRUNC('hour', m.fill_timestamp) = np.price_hour", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_deposit_fill_matching\"", "batch_results": null}], "elapsed_time": 2.0000739097595215, "args": {"partial_parse_file_diff": true, "log_format": "default", "printer_width": 80, "require_explicit_package_overrides_for_builtin_materializations": true, "use_fast_test_edges": false, "show_resource_report": false, "write_json": true, "log_level_file": "debug", "log_level": "info", "defer": false, "profiles_dir": "C:\\Users\\Longin\\.dbt", "require_batched_execution_for_custom_microbatch_strategy": false, "warn_error_options": {"error": [], "warn": [], "silence": []}, "static_parser": true, "upload_to_artifacts_ingest_api": false, "require_nested_cumulative_type_params": false, "indirect_selection": "eager", "send_anonymous_usage_stats": true, "project_dir": "C:\\Users\\Longin\\Desktop\\Projects\\across_analytics", "log_format_file": "debug", "log_path": "C:\\Users\\Longin\\Desktop\\Projects\\across_analytics\\logs", "print": true, "require_generic_test_arguments_property": true, "source_freshness_run_project_hooks": true, "state_modified_compare_vars": false, "cache_selected_only": false, "partial_parse": true, "select": ["intermediate"], "favor_state": false, "populate_cache": true, "introspect": true, "log_file_max_bytes": 10485760, "require_yaml_configuration_for_mf_time_spines": false, "macro_debugging": false, "require_all_warnings_handled_by_warn_error": false, "validate_macro_args": false, "skip_nodes_if_on_run_start_fails": false, "invocation_command": "dbt run --select intermediate", "empty": false, "show_all_deprecations": false, "strict_mode": false, "use_colors": true, "vars": {}, "exclude": [], "which": "run", "use_colors_file": true, "version_check": true, "state_modified_compare_more_unrendered_values": false, "require_resource_names_without_spaces": true, "quiet": false}}