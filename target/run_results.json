{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.10.15", "generated_at": "2025-12-27T22:42:12.997255Z", "invocation_id": "26810ee6-f765-483e-b0e8-f7ee29f44b8e", "invocation_started_at": "2025-12-27T22:42:09.054916Z", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-27T22:42:12.021649Z", "completed_at": "2025-12-27T22:42:12.049892Z"}, {"name": "execute", "started_at": "2025-12-27T22:42:12.051330Z", "completed_at": "2025-12-27T22:42:12.573585Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.5933761596679688, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_refunds", "compiled": true, "compiled_code": "-- int_unified_refunds.sql\n-- PURPOSE: Combine refunds from ALL chains into ONE table with converted amounts\n-- WHY: Refunds = capital returning to relayers. Tracks when relayers get paid back.\n\n\n\n-- Token metadata for amount conversion\nWITH token_meta AS (\n    \n    SELECT \n        LOWER(token_address) AS token_address,\n        token_symbol,\n        decimals,\n        chain_id\n    FROM \"across_analytics\".\"dbt\".\"token_metadata\"\n\n),\n\n-- Each CTE selects from a chain's staging model\narbitrum_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'arbitrum' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_arbitrum__refunds\"\n),\n\nethereum_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'ethereum' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_ethereum__refunds\"\n),\n\npolygon_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'polygon' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_polygon__refunds\"\n),\n\nlinea_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'linea' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_linea__refunds\"\n),\n\nworldchain_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'worldchain' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_worldchain__refunds\"\n),\n\nunichain_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'unichain' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_unichain__refunds\"\n),\n\nhyperevm_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'hyperevm' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_hyperevm__refunds\"\n),\n\nmonad_refunds AS (\n    SELECT \n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        LOWER(refund_token_address) AS refund_token_address,\n        total_refund_amount AS total_refund_amount_raw,\n        refund_addresses_string,\n        refund_amounts_string,\n        refund_count,\n        'monad' AS source_blockchain\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_monad__refunds\"\n),\n\n-- UNION ALL: Stack all refunds from all chains\nall_refunds AS (\n    SELECT * FROM arbitrum_refunds\n    UNION ALL\n    SELECT * FROM ethereum_refunds\n    UNION ALL\n    SELECT * FROM polygon_refunds\n    UNION ALL\n    SELECT * FROM linea_refunds\n    UNION ALL\n    SELECT * FROM worldchain_refunds\n    UNION ALL\n    SELECT * FROM unichain_refunds\n    UNION ALL\n    SELECT * FROM hyperevm_refunds\n    UNION ALL\n    SELECT * FROM monad_refunds\n)\n\n-- Final SELECT: Join with token metadata and convert amounts\nSELECT\n    r.refund_timestamp,\n    r.transaction_hash,\n    r.chain_id,\n    r.root_bundle_id,\n    r.leaf_id,\n    r.refund_token_address,\n    tok.token_symbol AS refund_token_symbol,\n    -- Rescaled amount (human-readable)\n    \n    r.total_refund_amount_raw / POWER(10, COALESCE(tok.decimals, 18))\n AS total_refund_amount,\n    -- Raw amount (preserved for auditing)\n    r.total_refund_amount_raw,\n    r.refund_addresses_string,\n    r.refund_amounts_string,\n    r.refund_count,\n    r.source_blockchain\n\nFROM all_refunds r\n\n-- Join with token metadata on address + chain_id\nLEFT JOIN token_meta AS tok\n    ON r.refund_token_address = tok.token_address\n    AND r.chain_id = tok.chain_id", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_refunds\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-27T22:42:11.992903Z", "completed_at": "2025-12-27T22:42:12.058401Z"}, {"name": "execute", "started_at": "2025-12-27T22:42:12.087605Z", "completed_at": "2025-12-27T22:42:12.576463Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.5992777347564697, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_deposits", "compiled": true, "compiled_code": "-- int_unified_deposits.sql\n-- PURPOSE: Combine deposits from ALL chains into ONE table\n-- WHY: Right now deposits are separate per chain. We need them unified to track cross-chain flows.\n\n\n\n-- Each CTE selects from a chain's staging model and adds the origin chain ID\nWITH arbitrum_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        42161 AS origin_chain_id,  -- Arbitrum's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_arbitrum__deposits\"\n),\n\nethereum_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        1 AS origin_chain_id,  -- Ethereum's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_ethereum__deposits\"\n),\n\npolygon_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        137 AS origin_chain_id,  -- Polygon's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_polygon__deposits\"\n),\n\nlinea_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        59144 AS origin_chain_id,  -- Linea's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_linea__deposits\"\n),\n\nworldchain_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        480 AS origin_chain_id,  -- WorldChain's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_worldchain__deposits\"\n),\n\nunichain_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        130 AS origin_chain_id,  -- Unichain's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_unichain__deposits\"\n),\n\nhyperevm_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        999 AS origin_chain_id,  -- HyperEVM's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_hyperevm__deposits\"\n),\n\nmonad_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        143 AS origin_chain_id,  -- Monad's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_monad__deposits\"\n)\n\n-- Supported chain IDs (chains we have parquet data for)\n-- 42161=Arbitrum, 1=Ethereum, 137=Polygon, 59144=Linea, 480=Worldchain, 130=Unichain, 999=HyperEVM, 143=Monad\n\n-- UNION ALL: Stack all deposits from all chains into one table\n-- Filter: Only include deposits where destination_chain_id is a supported chain\nSELECT * FROM arbitrum_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM ethereum_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM polygon_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM linea_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM worldchain_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM unichain_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM hyperevm_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM monad_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_deposits\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-27T22:42:12.037238Z", "completed_at": "2025-12-27T22:42:12.150297Z"}, {"name": "execute", "started_at": "2025-12-27T22:42:12.187711Z", "completed_at": "2025-12-27T22:42:12.579187Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.5950117111206055, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_fills", "compiled": true, "compiled_code": "-- int_unified_fills.sql\n-- PURPOSE: Combine fills from ALL chains into ONE table\n-- WHY: Fills happen on the DESTINATION chain. We need to see all fills to match with deposits.\n\n\n\n-- Each CTE selects from a chain's staging model and adds the destination chain ID\nWITH arbitrum_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        42161 AS destination_chain_id,  -- Fill happened ON Arbitrum\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        input_amount,\n        output_amount,\n        repayment_chain_id\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_arbitrum__fills\"\n),\n\nethereum_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        1 AS destination_chain_id,  -- Fill happened ON Ethereum\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        input_amount,\n        output_amount,\n        repayment_chain_id\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_ethereum__fills\"\n),\n\npolygon_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        137 AS destination_chain_id,  -- Fill happened ON Polygon\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        input_amount,\n        output_amount,\n        repayment_chain_id\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_polygon__fills\"\n),\n\nlinea_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        59144 AS destination_chain_id,  -- Fill happened ON Linea\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        input_amount,\n        output_amount,\n        repayment_chain_id\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_linea__fills\"\n),\n\nworldchain_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        480 AS destination_chain_id,  -- Fill happened ON WorldChain\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        input_amount,\n        output_amount,\n        repayment_chain_id\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_worldchain__fills\"\n),\n\nunichain_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        130 AS destination_chain_id,  -- Fill happened ON Unichain\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        input_amount,\n        output_amount,\n        repayment_chain_id\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_unichain__fills\"\n),\n\nhyperevm_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        999 AS destination_chain_id,  -- Fill happened ON HyperEVM\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        input_amount,\n        output_amount,\n        repayment_chain_id\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_hyperevm__fills\"\n),\n\nmonad_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        143 AS destination_chain_id,  -- Fill happened ON Monad\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        input_amount,\n        output_amount,\n        repayment_chain_id\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_monad__fills\"\n)\n\n-- Supported chain IDs (chains we have parquet data for)\n-- 42161=Arbitrum, 1=Ethereum, 137=Polygon, 59144=Linea, 480=Worldchain, 130=Unichain, 999=HyperEVM, 143=Monad\n\n-- UNION ALL: Stack all fills from all chains into one table\n-- Filter: Only include fills where origin_chain_id is a supported chain\nSELECT * FROM arbitrum_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM ethereum_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM polygon_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM linea_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM worldchain_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM unichain_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM hyperevm_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\nUNION ALL\nSELECT * FROM monad_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-27T22:42:12.615922Z", "completed_at": "2025-12-27T22:42:12.642889Z"}, {"name": "execute", "started_at": "2025-12-27T22:42:12.644222Z", "completed_at": "2025-12-27T22:42:12.866455Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.2572593688964844, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_deposit_fill_matching", "compiled": true, "compiled_code": "-- int_deposit_fill_matching.sql\n-- PURPOSE: Match every deposit to its fill (if it exists)\n-- WHY: This is the CORE model - connects money leaving one chain to money arriving on another.\n-- \n-- HOW IT WORKS:\n-- 1. User deposits on Chain A \u2192 creates deposit_id\n-- 2. Relayer fills on Chain B \u2192 same deposit_id\n-- 3. We JOIN on deposit_id + origin/destination chain match\n-- 4. Unfilled deposits = rows with NULL fill (stuck capital)\n\n\n\nWITH deposits AS (\n    SELECT * FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_deposits\"\n),\n\nfills AS (\n    SELECT * FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_fills\"\n),\n\n-- JOIN deposits to fills on deposit_id + chain matching\nmatched AS (\n    SELECT\n        -- === DEPOSIT INFO (Origin side) ===\n        d.deposit_timestamp,\n        d.transaction_hash AS deposit_tx_hash,\n        d.origin_chain_id,\n        d.destination_chain_id,\n        d.deposit_id,\n        d.depositor_address,\n        d.recipient_address AS deposit_recipient,\n        d.input_token_address AS deposit_token,\n        d.input_amount AS deposit_amount,\n        d.output_amount AS expected_output_amount,\n        \n        -- === FILL INFO (Destination side) ===\n        f.fill_timestamp,\n        f.transaction_hash AS fill_tx_hash,\n        f.relayer_address,\n        f.output_token_address AS fill_token,\n        f.output_amount AS actual_output_amount,\n        f.repayment_chain_id,\n        \n        -- === COMPUTED FIELDS ===\n        -- Fill latency: How long did it take to fill? (in seconds)\n        -- Use GREATEST(0, ...) to handle cross-chain timestamp sync issues\n        GREATEST(0, EXTRACT(EPOCH FROM (f.fill_timestamp - d.deposit_timestamp))) AS fill_latency_seconds,\n        \n        -- Is this deposit filled?\n        CASE WHEN f.deposit_id IS NOT NULL THEN TRUE ELSE FALSE END AS is_filled,\n        \n        -- Slippage: Difference between expected and actual output\n        CASE \n            WHEN f.output_amount IS NOT NULL AND d.output_amount > 0 \n            THEN ROUND(((d.output_amount - f.output_amount) / d.output_amount * 100)::NUMERIC, 2)\n            ELSE NULL \n        END AS slippage_percent\n\n    FROM deposits d\n    \n    -- LEFT JOIN: Keep ALL deposits, even unfilled ones\n    LEFT JOIN fills f \n        ON d.deposit_id = f.deposit_id\n        AND d.origin_chain_id = f.origin_chain_id  -- Must match origin\n        AND d.destination_chain_id = f.destination_chain_id  -- Must match destination\n)\n\nSELECT\n    -- Identity\n    deposit_timestamp,\n    deposit_tx_hash,\n    origin_chain_id,\n    destination_chain_id,\n    deposit_id,\n    \n    -- Deposit details\n    depositor_address,\n    deposit_recipient,\n    deposit_token,\n    deposit_amount,\n    expected_output_amount,\n    \n    -- Fill details (NULL if unfilled)\n    fill_timestamp,\n    fill_tx_hash,\n    relayer_address,\n    fill_token,\n    actual_output_amount,\n    repayment_chain_id,\n    \n    -- Metrics\n    fill_latency_seconds,\n    is_filled,\n    slippage_percent,\n    \n    -- Route identifier (for aggregations)\n    origin_chain_id || '_' || destination_chain_id AS route_id\n\nFROM matched", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_deposit_fill_matching\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-27T22:42:12.607363Z", "completed_at": "2025-12-27T22:42:12.631005Z"}, {"name": "execute", "started_at": "2025-12-27T22:42:12.631806Z", "completed_at": "2025-12-27T22:42:12.869591Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.26906347274780273, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_refunds_expanded", "compiled": true, "compiled_code": "-- int_refunds_expanded.sql\n-- CHALLENGE: some refund_amounts_string are arrays that have to be unnested\n-- PURPOSE: Expand comma-separated refund arrays into individual rows\n-- WHY: Each row = one relayer receiving one refund amount\n-- ENABLES: Easy aggregation, filtering by relayer, joins with relayer metrics\n\n\n\nWITH unified AS (\n    -- Get all refunds from all chains (already unified in int_unified_refunds)\n    SELECT * \n    FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_refunds\"\n    WHERE refund_count > 0  -- Only process batches with actual refunds\n),\n\n-- Unnest the comma-separated strings into individual rows\n-- Uses CROSS JOIN LATERAL with UNNEST to expand arrays\n-- WITH ORDINALITY gives us the position index for matching amounts to addresses\nexpanded AS (\n    SELECT\n        -- Batch-level identifiers (same for all rows from same batch)\n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        root_bundle_id,\n        leaf_id,\n        refund_token_address,\n        refund_token_symbol,\n        total_refund_amount,\n        total_refund_amount_raw,\n        refund_count,\n        source_blockchain,\n        \n        -- Individual refund data (one row per relayer/amount pair)\n        -- TRIM handles any whitespace that might exist in the CSV-like strings\n        TRIM(amounts.amount)::NUMERIC AS refund_amount_raw,\n        TRIM(addresses.address) AS relayer_address,\n        amounts.idx AS refund_index\n        \n    FROM unified\n    -- Expand refund_amounts_string: \"100,200,300\" \u2192 3 rows with values 100, 200, 300\n    CROSS JOIN LATERAL UNNEST(\n        string_to_array(refund_amounts_string, ',')\n    ) WITH ORDINALITY AS amounts(amount, idx)\n    -- Expand refund_addresses_string: \"0xAAA,0xBBB,0xCCC\" \u2192 3 rows with addresses\n    CROSS JOIN LATERAL UNNEST(\n        string_to_array(refund_addresses_string, ',')\n    ) WITH ORDINALITY AS addresses(address, idx)\n    -- Match by position: 1st amount goes to 1st address, 2nd to 2nd, etc.\n    WHERE amounts.idx = addresses.idx\n)\n\nSELECT\n    -- Event identification\n    refund_timestamp,\n    transaction_hash,\n    source_blockchain,\n    \n    -- Batch identifiers (for grouping back if needed)\n    chain_id,\n    root_bundle_id,\n    leaf_id,\n    \n    -- Individual refund details\n    refund_index,\n    relayer_address,\n    refund_token_address,\n    refund_token_symbol,\n    \n    -- Individual refund amount (rescaled using same decimals as batch total)\n    -- Since int_unified_refunds already joined with token_meta, we use same conversion\n    CASE \n        WHEN total_refund_amount_raw > 0 AND total_refund_amount > 0 \n        THEN refund_amount_raw * (total_refund_amount / total_refund_amount_raw)\n        ELSE refund_amount_raw\n    END AS refund_amount,\n    refund_amount_raw,\n    \n    -- Batch context (useful for analysis)\n    total_refund_amount AS batch_total_amount,\n    total_refund_amount_raw AS batch_total_amount_raw,\n    refund_count AS batch_refund_count,\n    \n    -- Unique identifier for each individual refund record\n    transaction_hash || '-' || leaf_id || '-' || refund_index AS refund_id\n    \nFROM expanded", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_refunds_expanded\"", "batch_results": null}], "elapsed_time": 1.6656413078308105, "args": {"indirect_selection": "eager", "log_file_max_bytes": 10485760, "show_resource_report": false, "strict_mode": false, "upload_to_artifacts_ingest_api": false, "invocation_command": "dbt run --select intermediate", "state_modified_compare_more_unrendered_values": false, "show_all_deprecations": false, "skip_nodes_if_on_run_start_fails": false, "quiet": false, "cache_selected_only": false, "require_explicit_package_overrides_for_builtin_materializations": true, "version_check": true, "partial_parse_file_diff": true, "log_level": "info", "validate_macro_args": false, "partial_parse": true, "vars": {}, "print": true, "require_yaml_configuration_for_mf_time_spines": false, "require_batched_execution_for_custom_microbatch_strategy": false, "require_resource_names_without_spaces": true, "introspect": true, "log_path": "C:\\Users\\Longin\\Desktop\\Projects\\across_analytics\\logs", "populate_cache": true, "project_dir": "C:\\Users\\Longin\\Desktop\\Projects\\across_analytics", "source_freshness_run_project_hooks": true, "which": "run", "macro_debugging": false, "require_all_warnings_handled_by_warn_error": false, "require_nested_cumulative_type_params": false, "static_parser": true, "use_colors": true, "favor_state": false, "log_format_file": "debug", "profiles_dir": "C:\\Users\\Longin\\.dbt", "use_colors_file": true, "use_fast_test_edges": false, "printer_width": 80, "state_modified_compare_vars": false, "send_anonymous_usage_stats": true, "empty": false, "require_generic_test_arguments_property": true, "write_json": true, "defer": false, "exclude": [], "log_format": "default", "select": ["intermediate"], "warn_error_options": {"error": [], "warn": [], "silence": []}, "log_level_file": "debug"}}