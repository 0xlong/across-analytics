{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.10.15", "generated_at": "2025-12-12T12:59:01.626636Z", "invocation_id": "ea6fe37f-a2d4-4c50-9a62-8a379ac97dbc", "invocation_started_at": "2025-12-12T12:58:58.063018Z", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-12T12:59:00.589514Z", "completed_at": "2025-12-12T12:59:00.607179Z"}, {"name": "execute", "started_at": "2025-12-12T12:59:00.613565Z", "completed_at": "2025-12-12T12:59:00.998264Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.42975521087646484, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.stg_arbitrum__fills", "compiled": true, "compiled_code": "-- Staging model for FilledRelay events from Arbitrum\r\n\r\nWITH raw_fills AS (\r\n\r\n    SELECT\r\n        -- Core event metadata - these identify WHEN and WHERE the event happened\r\n        timestamp_datetime,              -- When the event occurred (from blockchain)\r\n        transactionHash,                 -- Unique transaction identifier\r\n        blockchain,                      -- Which blockchain (should be 'arbitrum')\r\n        source_file,                     -- Which source file this came from (for lineage)\r\n        \r\n        -- Indexed fields from topics (these are searchable/filterable in blockchain)\r\n        -- Topics are like \"indexed columns\" in SQL - they're stored separately for fast queries\r\n        topic_origin_chain_id,           -- Chain ID where the original deposit happened\r\n        topic_deposit_id,                -- Unique deposit identifier (links to deposit event)\r\n        topic_relayer,                   -- Address of the relayer who provided liquidity\r\n        \r\n        -- Non-indexed fields from the event's data field\r\n        -- These are the actual business data about the fill\r\n        filled_relay_data_input_token,          -- Token address on origin chain\r\n        filled_relay_data_output_token,          -- Token address on destination chain\r\n        filled_relay_data_input_amount,          -- Amount sent (in origin token units)\r\n        filled_relay_data_output_amount,         -- Amount received (in destination token units)\r\n        filled_relay_data_repayment_chain_id,     -- Where relayer gets reimbursed\r\n        filled_relay_data_exclusive_relayer,     -- Address with exclusive fill rights (if any)\r\n        filled_relay_data_depositor,             -- Original user who initiated the bridge\r\n        filled_relay_data_recipient              -- Final recipient of the bridged funds\r\n        \r\n    FROM raw.arbitrum_logs_processed\r\n    \r\n    -- Filter: Only include rows where FilledRelay data exists\r\n    WHERE topic_0 = '0x44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208'\r\n        AND filled_relay_data_input_amount IS NOT NULL\r\n        AND filled_relay_data_output_amount IS NOT NULL\r\n),\r\n\r\ncleaned_fills AS (\r\n    SELECT\r\n        \r\n        -- Timestamp: Convert text to proper timestamp type\r\n        \r\n        CASE \r\n            WHEN timestamp_datetime ~ '^\\d+$' THEN          -- If it's pure digits, treat as Unix timestamp (seconds since 1970-01-01)\r\n                TO_TIMESTAMP(timestamp_datetime::BIGINT)    -- PostgreSQL's TO_TIMESTAMP can parse various formats, but we use the simplest approach\r\n            ELSE \r\n                timestamp_datetime::TIMESTAMP               -- Otherwise, try to parse as ISO format string\r\n        END AS fill_timestamp,\r\n        \r\n        transactionHash AS transaction_hash,\r\n        blockchain,\r\n        source_file,\r\n        \r\n        -- ============================================================\r\n        -- INDEXED FIELDS (from topics) - Already decoded by ETL\r\n        -- ============================================================\r\n        -- These come from the event's \"topics\" array, which is indexed for fast blockchain queries\r\n        \r\n        -- Origin chain ID: Which blockchain the funds came FROM\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- Example: 1 = Ethereum, 42161 = Arbitrum, 8453 = Base\r\n        -- Cast via NUMERIC first to handle decimal strings like \"8453.0\" from ETL\r\n        (topic_origin_chain_id::NUMERIC)::BIGINT AS origin_chain_id,\r\n        \r\n        -- Deposit ID: Unique identifier linking this fill to its original deposit\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- This is the KEY that connects deposits \u2194 fills across chains\r\n        -- Cast via NUMERIC first to handle decimal strings like \"12345.0\" from ETL\r\n        (topic_deposit_id::NUMERIC)::BIGINT AS deposit_id,\r\n        \r\n        -- Relayer address: Who provided the liquidity\r\n        -- Already decoded by ETL to proper address format (0x...)\r\n        topic_relayer AS relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- TOKEN INFORMATION (what was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input token: The token address on the origin chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Example: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 = USDC on Ethereum\r\n        filled_relay_data_input_token AS input_token_address,\r\n        \r\n        -- Output token: The token address on the destination chain (Arbitrum in this case)\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_output_token AS output_token_address,\r\n        \r\n        -- ============================================================\r\n        -- AMOUNT INFORMATION (how much was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input amount: How much was sent from origin chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        filled_relay_data_input_amount::NUMERIC AS input_amount,\r\n        \r\n        -- Output amount: How much was received on destination chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Usually slightly less than input due to fees/spread\r\n        filled_relay_data_output_amount::NUMERIC AS output_amount,\r\n        \r\n        -- ============================================================\r\n        -- RELAYER & ROUTING INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Repayment chain ID: Where the relayer gets reimbursed\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Relayers front capital, then get paid back (often on a different chain)\r\n        -- Cast via NUMERIC first to handle decimal strings like \"1.0\" from ETL\r\n        (filled_relay_data_repayment_chain_id::NUMERIC)::BIGINT AS repayment_chain_id,\r\n        \r\n        -- Exclusive relayer: If set, only this address can fill this deposit\r\n        -- Already decoded by ETL to proper address format\r\n        -- Used for priority/guaranteed fills (NULL if no exclusive relayer)\r\n        filled_relay_data_exclusive_relayer AS exclusive_relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- USER INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Depositor: The original user who initiated the bridge\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_depositor AS depositor_address,\r\n        \r\n        -- Recipient: Who receives the funds on the destination chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Usually the same as depositor, but can be different (gift/transfer)\r\n        filled_relay_data_recipient AS recipient_address\r\n        \r\n    FROM raw_fills\r\n)\r\n\r\n-- Final SELECT: Add any computed fields and ensure data quality\r\nSELECT\r\n    -- Event identity\r\n    fill_timestamp,\r\n    transaction_hash,\r\n    blockchain,\r\n    source_file,\r\n    \r\n    -- Indexed fields\r\n    origin_chain_id,\r\n    deposit_id,\r\n    relayer_address,\r\n    \r\n    -- Token info\r\n    input_token_address,\r\n    output_token_address,\r\n    \r\n    -- Amounts\r\n    input_amount,\r\n    output_amount,\r\n    \r\n    -- Relayer routing\r\n    repayment_chain_id,\r\n    exclusive_relayer_address,\r\n    \r\n    -- User info\r\n    depositor_address,\r\n    recipient_address\r\n    \r\nFROM cleaned_fills\r\n\r\n-- Data quality: Only include rows with essential fields populated\r\nWHERE deposit_id IS NOT NULL\r\n    AND relayer_address IS NOT NULL\r\n    AND input_token_address IS NOT NULL\r\n    AND output_token_address IS NOT NULL\r\n    AND input_amount IS NOT NULL\r\n    AND output_amount IS NOT NULL", "relation_name": "\"across_analytics\".\"staging\".\"stg_arbitrum__fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-12T12:59:00.580224Z", "completed_at": "2025-12-12T12:59:00.608897Z"}, {"name": "execute", "started_at": "2025-12-12T12:59:00.687697Z", "completed_at": "2025-12-12T12:59:01.024741Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.4527420997619629, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.stg_hyperevm__fills", "compiled": true, "compiled_code": "-- Staging model for FilledRelay events from HyperEVM\r\n\r\nWITH raw_fills AS (\r\n\r\n    SELECT\r\n        -- Core event metadata - these identify WHEN and WHERE the event happened\r\n        timestamp_datetime,              -- When the event occurred (from blockchain)\r\n        transactionHash,                 -- Unique transaction identifier\r\n        blockchain,                      -- Which blockchain (should be 'hyperevm')\r\n        source_file,                     -- Which source file this came from (for lineage)\r\n        \r\n        -- Indexed fields from topics (these are searchable/filterable in blockchain)\r\n        -- Topics are like \"indexed columns\" in SQL - they're stored separately for fast queries\r\n        topic_origin_chain_id,           -- Chain ID where the original deposit happened\r\n        topic_deposit_id,                -- Unique deposit identifier (links to deposit event)\r\n        topic_relayer,                   -- Address of the relayer who provided liquidity\r\n        \r\n        -- Non-indexed fields from the event's data field\r\n        -- These are the actual business data about the fill\r\n        filled_relay_data_input_token,          -- Token address on origin chain\r\n        filled_relay_data_output_token,          -- Token address on destination chain\r\n        filled_relay_data_input_amount,          -- Amount sent (in origin token units)\r\n        filled_relay_data_output_amount,         -- Amount received (in destination token units)\r\n        filled_relay_data_repayment_chain_id,     -- Where relayer gets reimbursed\r\n        filled_relay_data_exclusive_relayer,     -- Address with exclusive fill rights (if any)\r\n        filled_relay_data_depositor,             -- Original user who initiated the bridge\r\n        filled_relay_data_recipient              -- Final recipient of the bridged funds\r\n        \r\n    FROM raw.hyperevm_logs_processed\r\n    \r\n    -- Filter: Only include rows where FilledRelay data exists\r\n    WHERE topic_0 = '0x44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208'\r\n        AND filled_relay_data_input_amount IS NOT NULL\r\n        AND filled_relay_data_output_amount IS NOT NULL\r\n),\r\n\r\ncleaned_fills AS (\r\n    SELECT\r\n        \r\n        -- Timestamp: Convert text to proper timestamp type\r\n        \r\n        CASE \r\n            WHEN timestamp_datetime ~ '^\\d+$' THEN          -- If it's pure digits, treat as Unix timestamp (seconds since 1970-01-01)\r\n                TO_TIMESTAMP(timestamp_datetime::BIGINT)    -- PostgreSQL's TO_TIMESTAMP can parse various formats, but we use the simplest approach\r\n            ELSE \r\n                timestamp_datetime::TIMESTAMP               -- Otherwise, try to parse as ISO format string\r\n        END AS fill_timestamp,\r\n        \r\n        transactionHash AS transaction_hash,\r\n        blockchain,\r\n        source_file,\r\n        \r\n        -- ============================================================\r\n        -- INDEXED FIELDS (from topics) - Already decoded by ETL\r\n        -- ============================================================\r\n        -- These come from the event's \"topics\" array, which is indexed for fast blockchain queries\r\n        \r\n        -- Origin chain ID: Which blockchain the funds came FROM\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- Example: 1 = Ethereum, 42161 = Arbitrum, 8453 = Base\r\n        -- Cast via NUMERIC first to handle decimal strings like \"8453.0\" from ETL\r\n        (topic_origin_chain_id::NUMERIC)::BIGINT AS origin_chain_id,\r\n        \r\n        -- Deposit ID: Unique identifier linking this fill to its original deposit\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- This is the KEY that connects deposits \u2194 fills across chains\r\n        -- Cast via NUMERIC first to handle decimal strings like \"12345.0\" from ETL\r\n        (topic_deposit_id::NUMERIC)::BIGINT AS deposit_id,\r\n        \r\n        -- Relayer address: Who provided the liquidity\r\n        -- Already decoded by ETL to proper address format (0x...)\r\n        topic_relayer AS relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- TOKEN INFORMATION (what was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input token: The token address on the origin chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Example: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 = USDC on Ethereum\r\n        filled_relay_data_input_token AS input_token_address,\r\n        \r\n        -- Output token: The token address on the destination chain (HyperEVM in this case)\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_output_token AS output_token_address,\r\n        \r\n        -- ============================================================\r\n        -- AMOUNT INFORMATION (how much was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input amount: How much was sent from origin chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        filled_relay_data_input_amount::NUMERIC AS input_amount,\r\n        \r\n        -- Output amount: How much was received on destination chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Usually slightly less than input due to fees/spread\r\n        filled_relay_data_output_amount::NUMERIC AS output_amount,\r\n        \r\n        -- ============================================================\r\n        -- RELAYER & ROUTING INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Repayment chain ID: Where the relayer gets reimbursed\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Relayers front capital, then get paid back (often on a different chain)\r\n        -- Cast via NUMERIC first to handle decimal strings like \"1.0\" from ETL\r\n        (filled_relay_data_repayment_chain_id::NUMERIC)::BIGINT AS repayment_chain_id,\r\n        \r\n        -- Exclusive relayer: If set, only this address can fill this deposit\r\n        -- Already decoded by ETL to proper address format\r\n        -- Used for priority/guaranteed fills (NULL if no exclusive relayer)\r\n        filled_relay_data_exclusive_relayer AS exclusive_relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- USER INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Depositor: The original user who initiated the bridge\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_depositor AS depositor_address,\r\n        \r\n        -- Recipient: Who receives the funds on the destination chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Usually the same as depositor, but can be different (gift/transfer)\r\n        filled_relay_data_recipient AS recipient_address\r\n        \r\n    FROM raw_fills\r\n)\r\n\r\n-- Final SELECT: Add any computed fields and ensure data quality\r\nSELECT\r\n    -- Event identity\r\n    fill_timestamp,\r\n    transaction_hash,\r\n    blockchain,\r\n    source_file,\r\n    \r\n    -- Indexed fields\r\n    origin_chain_id,\r\n    deposit_id,\r\n    relayer_address,\r\n    \r\n    -- Token info\r\n    input_token_address,\r\n    output_token_address,\r\n    \r\n    -- Amounts\r\n    input_amount,\r\n    output_amount,\r\n    \r\n    -- Relayer routing\r\n    repayment_chain_id,\r\n    exclusive_relayer_address,\r\n    \r\n    -- User info\r\n    depositor_address,\r\n    recipient_address\r\n    \r\nFROM cleaned_fills\r\n\r\n-- Data quality: Only include rows with essential fields populated\r\nWHERE deposit_id IS NOT NULL\r\n    AND relayer_address IS NOT NULL\r\n    AND input_token_address IS NOT NULL\r\n    AND output_token_address IS NOT NULL\r\n    AND input_amount IS NOT NULL\r\n    AND output_amount IS NOT NULL", "relation_name": "\"across_analytics\".\"staging\".\"stg_hyperevm__fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-12T12:59:00.610226Z", "completed_at": "2025-12-12T12:59:00.760935Z"}, {"name": "execute", "started_at": "2025-12-12T12:59:00.762879Z", "completed_at": "2025-12-12T12:59:01.036182Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.4446585178375244, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.stg_linea__fills", "compiled": true, "compiled_code": "-- Staging model for FilledRelay events from Linea\r\n\r\nWITH raw_fills AS (\r\n\r\n    SELECT\r\n        -- Core event metadata - these identify WHEN and WHERE the event happened\r\n        timestamp_datetime,              -- When the event occurred (from blockchain)\r\n        transactionHash,                 -- Unique transaction identifier\r\n        blockchain,                      -- Which blockchain (should be 'linea')\r\n        source_file,                     -- Which source file this came from (for lineage)\r\n        \r\n        -- Indexed fields from topics (these are searchable/filterable in blockchain)\r\n        -- Topics are like \"indexed columns\" in SQL - they're stored separately for fast queries\r\n        topic_origin_chain_id,           -- Chain ID where the original deposit happened\r\n        topic_deposit_id,                -- Unique deposit identifier (links to deposit event)\r\n        topic_relayer,                   -- Address of the relayer who provided liquidity\r\n        \r\n        -- Non-indexed fields from the event's data field\r\n        -- These are the actual business data about the fill\r\n        filled_relay_data_input_token,          -- Token address on origin chain\r\n        filled_relay_data_output_token,          -- Token address on destination chain\r\n        filled_relay_data_input_amount,          -- Amount sent (in origin token units)\r\n        filled_relay_data_output_amount,         -- Amount received (in destination token units)\r\n        filled_relay_data_repayment_chain_id,     -- Where relayer gets reimbursed\r\n        filled_relay_data_exclusive_relayer,     -- Address with exclusive fill rights (if any)\r\n        filled_relay_data_depositor,             -- Original user who initiated the bridge\r\n        filled_relay_data_recipient              -- Final recipient of the bridged funds\r\n        \r\n    FROM raw.linea_logs_processed\r\n    \r\n    -- Filter: Only include rows where FilledRelay data exists\r\n    WHERE topic_0 = '0x44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208'\r\n        AND filled_relay_data_input_amount IS NOT NULL\r\n        AND filled_relay_data_output_amount IS NOT NULL\r\n),\r\n\r\ncleaned_fills AS (\r\n    SELECT\r\n        \r\n        -- Timestamp: Convert text to proper timestamp type\r\n        \r\n        CASE \r\n            WHEN timestamp_datetime ~ '^\\d+$' THEN          -- If it's pure digits, treat as Unix timestamp (seconds since 1970-01-01)\r\n                TO_TIMESTAMP(timestamp_datetime::BIGINT)    -- PostgreSQL's TO_TIMESTAMP can parse various formats, but we use the simplest approach\r\n            ELSE \r\n                timestamp_datetime::TIMESTAMP               -- Otherwise, try to parse as ISO format string\r\n        END AS fill_timestamp,\r\n        \r\n        transactionHash AS transaction_hash,\r\n        blockchain,\r\n        source_file,\r\n        \r\n        -- ============================================================\r\n        -- INDEXED FIELDS (from topics) - Already decoded by ETL\r\n        -- ============================================================\r\n        -- These come from the event's \"topics\" array, which is indexed for fast blockchain queries\r\n        \r\n        -- Origin chain ID: Which blockchain the funds came FROM\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- Example: 1 = Ethereum, 42161 = Arbitrum, 8453 = Base\r\n        -- Cast via NUMERIC first to handle decimal strings like \"8453.0\" from ETL\r\n        (topic_origin_chain_id::NUMERIC)::BIGINT AS origin_chain_id,\r\n        \r\n        -- Deposit ID: Unique identifier linking this fill to its original deposit\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- This is the KEY that connects deposits \u2194 fills across chains\r\n        -- Cast via NUMERIC first to handle decimal strings like \"12345.0\" from ETL\r\n        (topic_deposit_id::NUMERIC)::BIGINT AS deposit_id,\r\n        \r\n        -- Relayer address: Who provided the liquidity\r\n        -- Already decoded by ETL to proper address format (0x...)\r\n        topic_relayer AS relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- TOKEN INFORMATION (what was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input token: The token address on the origin chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Example: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 = USDC on Ethereum\r\n        filled_relay_data_input_token AS input_token_address,\r\n        \r\n        -- Output token: The token address on the destination chain (Linea in this case)\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_output_token AS output_token_address,\r\n        \r\n        -- ============================================================\r\n        -- AMOUNT INFORMATION (how much was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input amount: How much was sent from origin chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        filled_relay_data_input_amount::NUMERIC AS input_amount,\r\n        \r\n        -- Output amount: How much was received on destination chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Usually slightly less than input due to fees/spread\r\n        filled_relay_data_output_amount::NUMERIC AS output_amount,\r\n        \r\n        -- ============================================================\r\n        -- RELAYER & ROUTING INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Repayment chain ID: Where the relayer gets reimbursed\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Relayers front capital, then get paid back (often on a different chain)\r\n        -- Cast via NUMERIC first to handle decimal strings like \"1.0\" from ETL\r\n        (filled_relay_data_repayment_chain_id::NUMERIC)::BIGINT AS repayment_chain_id,\r\n        \r\n        -- Exclusive relayer: If set, only this address can fill this deposit\r\n        -- Already decoded by ETL to proper address format\r\n        -- Used for priority/guaranteed fills (NULL if no exclusive relayer)\r\n        filled_relay_data_exclusive_relayer AS exclusive_relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- USER INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Depositor: The original user who initiated the bridge\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_depositor AS depositor_address,\r\n        \r\n        -- Recipient: Who receives the funds on the destination chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Usually the same as depositor, but can be different (gift/transfer)\r\n        filled_relay_data_recipient AS recipient_address\r\n        \r\n    FROM raw_fills\r\n)\r\n\r\n-- Final SELECT: Add any computed fields and ensure data quality\r\nSELECT\r\n    -- Event identity\r\n    fill_timestamp,\r\n    transaction_hash,\r\n    blockchain,\r\n    source_file,\r\n    \r\n    -- Indexed fields\r\n    origin_chain_id,\r\n    deposit_id,\r\n    relayer_address,\r\n    \r\n    -- Token info\r\n    input_token_address,\r\n    output_token_address,\r\n    \r\n    -- Amounts\r\n    input_amount,\r\n    output_amount,\r\n    \r\n    -- Relayer routing\r\n    repayment_chain_id,\r\n    exclusive_relayer_address,\r\n    \r\n    -- User info\r\n    depositor_address,\r\n    recipient_address\r\n    \r\nFROM cleaned_fills\r\n\r\n-- Data quality: Only include rows with essential fields populated\r\nWHERE deposit_id IS NOT NULL\r\n    AND relayer_address IS NOT NULL\r\n    AND input_token_address IS NOT NULL\r\n    AND output_token_address IS NOT NULL\r\n    AND input_amount IS NOT NULL\r\n    AND output_amount IS NOT NULL", "relation_name": "\"across_analytics\".\"staging\".\"stg_linea__fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-12T12:59:00.599503Z", "completed_at": "2025-12-12T12:59:00.751297Z"}, {"name": "execute", "started_at": "2025-12-12T12:59:00.752561Z", "completed_at": "2025-12-12T12:59:01.047060Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.4778470993041992, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.stg_ethereum__fills", "compiled": true, "compiled_code": "-- Staging model for FilledRelay events from Ethereum\r\n\r\nWITH raw_fills AS (\r\n\r\n    SELECT\r\n        -- Core event metadata - these identify WHEN and WHERE the event happened\r\n        timestamp_datetime,              -- When the event occurred (from blockchain)\r\n        transactionHash,                 -- Unique transaction identifier\r\n        blockchain,                      -- Which blockchain (should be 'ethereum')\r\n        source_file,                     -- Which source file this came from (for lineage)\r\n        \r\n        -- Indexed fields from topics (these are searchable/filterable in blockchain)\r\n        -- Topics are like \"indexed columns\" in SQL - they're stored separately for fast queries\r\n        topic_origin_chain_id,           -- Chain ID where the original deposit happened\r\n        topic_deposit_id,                -- Unique deposit identifier (links to deposit event)\r\n        topic_relayer,                   -- Address of the relayer who provided liquidity\r\n        \r\n        -- Non-indexed fields from the event's data field\r\n        -- These are the actual business data about the fill\r\n        filled_relay_data_input_token,          -- Token address on origin chain\r\n        filled_relay_data_output_token,          -- Token address on destination chain\r\n        filled_relay_data_input_amount,          -- Amount sent (in origin token units)\r\n        filled_relay_data_output_amount,         -- Amount received (in destination token units)\r\n        filled_relay_data_repayment_chain_id,     -- Where relayer gets reimbursed\r\n        filled_relay_data_exclusive_relayer,     -- Address with exclusive fill rights (if any)\r\n        filled_relay_data_depositor,             -- Original user who initiated the bridge\r\n        filled_relay_data_recipient              -- Final recipient of the bridged funds\r\n        \r\n    FROM raw.ethereum_logs_processed\r\n    \r\n    -- Filter: Only include rows where FilledRelay data exists\r\n    WHERE topic_0 = '0x44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208'\r\n        AND filled_relay_data_input_amount IS NOT NULL\r\n        AND filled_relay_data_output_amount IS NOT NULL\r\n),\r\n\r\ncleaned_fills AS (\r\n    SELECT\r\n        \r\n        -- Timestamp: Convert text to proper timestamp type\r\n        \r\n        CASE \r\n            WHEN timestamp_datetime ~ '^\\d+$' THEN          -- If it's pure digits, treat as Unix timestamp (seconds since 1970-01-01)\r\n                TO_TIMESTAMP(timestamp_datetime::BIGINT)    -- PostgreSQL's TO_TIMESTAMP can parse various formats, but we use the simplest approach\r\n            ELSE \r\n                timestamp_datetime::TIMESTAMP               -- Otherwise, try to parse as ISO format string\r\n        END AS fill_timestamp,\r\n        \r\n        transactionHash AS transaction_hash,\r\n        blockchain,\r\n        source_file,\r\n        \r\n        -- ============================================================\r\n        -- INDEXED FIELDS (from topics) - Already decoded by ETL\r\n        -- ============================================================\r\n        -- These come from the event's \"topics\" array, which is indexed for fast blockchain queries\r\n        \r\n        -- Origin chain ID: Which blockchain the funds came FROM\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- Example: 1 = Ethereum, 42161 = Arbitrum, 8453 = Base\r\n        -- Cast via NUMERIC first to handle decimal strings like \"8453.0\" from ETL\r\n        (topic_origin_chain_id::NUMERIC)::BIGINT AS origin_chain_id,\r\n        \r\n        -- Deposit ID: Unique identifier linking this fill to its original deposit\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- This is the KEY that connects deposits \u2194 fills across chains\r\n        -- Cast via NUMERIC first to handle decimal strings like \"12345.0\" from ETL\r\n        (topic_deposit_id::NUMERIC)::BIGINT AS deposit_id,\r\n        \r\n        -- Relayer address: Who provided the liquidity\r\n        -- Already decoded by ETL to proper address format (0x...)\r\n        topic_relayer AS relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- TOKEN INFORMATION (what was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input token: The token address on the origin chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Example: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 = USDC on Ethereum\r\n        filled_relay_data_input_token AS input_token_address,\r\n        \r\n        -- Output token: The token address on the destination chain (Ethereum in this case)\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_output_token AS output_token_address,\r\n        \r\n        -- ============================================================\r\n        -- AMOUNT INFORMATION (how much was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input amount: How much was sent from origin chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        filled_relay_data_input_amount::NUMERIC AS input_amount,\r\n        \r\n        -- Output amount: How much was received on destination chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Usually slightly less than input due to fees/spread\r\n        filled_relay_data_output_amount::NUMERIC AS output_amount,\r\n        \r\n        -- ============================================================\r\n        -- RELAYER & ROUTING INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Repayment chain ID: Where the relayer gets reimbursed\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Relayers front capital, then get paid back (often on a different chain)\r\n        -- Cast via NUMERIC first to handle decimal strings like \"1.0\" from ETL\r\n        (filled_relay_data_repayment_chain_id::NUMERIC)::BIGINT AS repayment_chain_id,\r\n        \r\n        -- Exclusive relayer: If set, only this address can fill this deposit\r\n        -- Already decoded by ETL to proper address format\r\n        -- Used for priority/guaranteed fills (NULL if no exclusive relayer)\r\n        filled_relay_data_exclusive_relayer AS exclusive_relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- USER INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Depositor: The original user who initiated the bridge\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_depositor AS depositor_address,\r\n        \r\n        -- Recipient: Who receives the funds on the destination chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Usually the same as depositor, but can be different (gift/transfer)\r\n        filled_relay_data_recipient AS recipient_address\r\n        \r\n    FROM raw_fills\r\n)\r\n\r\n-- Final SELECT: Add any computed fields and ensure data quality\r\nSELECT\r\n    -- Event identity\r\n    fill_timestamp,\r\n    transaction_hash,\r\n    blockchain,\r\n    source_file,\r\n    \r\n    -- Indexed fields\r\n    origin_chain_id,\r\n    deposit_id,\r\n    relayer_address,\r\n    \r\n    -- Token info\r\n    input_token_address,\r\n    output_token_address,\r\n    \r\n    -- Amounts\r\n    input_amount,\r\n    output_amount,\r\n    \r\n    -- Relayer routing\r\n    repayment_chain_id,\r\n    exclusive_relayer_address,\r\n    \r\n    -- User info\r\n    depositor_address,\r\n    recipient_address\r\n    \r\nFROM cleaned_fills\r\n\r\n-- Data quality: Only include rows with essential fields populated\r\nWHERE deposit_id IS NOT NULL\r\n    AND relayer_address IS NOT NULL\r\n    AND input_token_address IS NOT NULL\r\n    AND output_token_address IS NOT NULL\r\n    AND input_amount IS NOT NULL\r\n    AND output_amount IS NOT NULL", "relation_name": "\"across_analytics\".\"staging\".\"stg_ethereum__fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-12T12:59:01.051808Z", "completed_at": "2025-12-12T12:59:01.064179Z"}, {"name": "execute", "started_at": "2025-12-12T12:59:01.068554Z", "completed_at": "2025-12-12T12:59:01.374920Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.34175562858581543, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.stg_monad__fills", "compiled": true, "compiled_code": "-- Staging model for FilledRelay events from Monad\r\n\r\nWITH raw_fills AS (\r\n\r\n    SELECT\r\n        -- Core event metadata - these identify WHEN and WHERE the event happened\r\n        timestamp_datetime,              -- When the event occurred (from blockchain)\r\n        transactionHash,                 -- Unique transaction identifier\r\n        blockchain,                      -- Which blockchain (should be 'monad')\r\n        source_file,                     -- Which source file this came from (for lineage)\r\n        \r\n        -- Indexed fields from topics (these are searchable/filterable in blockchain)\r\n        -- Topics are like \"indexed columns\" in SQL - they're stored separately for fast queries\r\n        topic_origin_chain_id,           -- Chain ID where the original deposit happened\r\n        topic_deposit_id,                -- Unique deposit identifier (links to deposit event)\r\n        topic_relayer,                   -- Address of the relayer who provided liquidity\r\n        \r\n        -- Non-indexed fields from the event's data field\r\n        -- These are the actual business data about the fill\r\n        filled_relay_data_input_token,          -- Token address on origin chain\r\n        filled_relay_data_output_token,          -- Token address on destination chain\r\n        filled_relay_data_input_amount,          -- Amount sent (in origin token units)\r\n        filled_relay_data_output_amount,         -- Amount received (in destination token units)\r\n        filled_relay_data_repayment_chain_id,     -- Where relayer gets reimbursed\r\n        filled_relay_data_exclusive_relayer,     -- Address with exclusive fill rights (if any)\r\n        filled_relay_data_depositor,             -- Original user who initiated the bridge\r\n        filled_relay_data_recipient              -- Final recipient of the bridged funds\r\n        \r\n    FROM raw.monad_logs_processed\r\n    \r\n    -- Filter: Only include rows where FilledRelay data exists\r\n    WHERE topic_0 = '0x44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208'\r\n        AND filled_relay_data_input_amount IS NOT NULL\r\n        AND filled_relay_data_output_amount IS NOT NULL\r\n),\r\n\r\ncleaned_fills AS (\r\n    SELECT\r\n        \r\n        -- Timestamp: Convert text to proper timestamp type\r\n        \r\n        CASE \r\n            WHEN timestamp_datetime ~ '^\\d+$' THEN          -- If it's pure digits, treat as Unix timestamp (seconds since 1970-01-01)\r\n                TO_TIMESTAMP(timestamp_datetime::BIGINT)    -- PostgreSQL's TO_TIMESTAMP can parse various formats, but we use the simplest approach\r\n            ELSE \r\n                timestamp_datetime::TIMESTAMP               -- Otherwise, try to parse as ISO format string\r\n        END AS fill_timestamp,\r\n        \r\n        transactionHash AS transaction_hash,\r\n        blockchain,\r\n        source_file,\r\n        \r\n        -- ============================================================\r\n        -- INDEXED FIELDS (from topics) - Already decoded by ETL\r\n        -- ============================================================\r\n        -- These come from the event's \"topics\" array, which is indexed for fast blockchain queries\r\n        \r\n        -- Origin chain ID: Which blockchain the funds came FROM\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- Example: 1 = Ethereum, 42161 = Arbitrum, 8453 = Base\r\n        -- Cast via NUMERIC first to handle decimal strings like \"8453.0\" from ETL\r\n        (topic_origin_chain_id::NUMERIC)::BIGINT AS origin_chain_id,\r\n        \r\n        -- Deposit ID: Unique identifier linking this fill to its original deposit\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- This is the KEY that connects deposits \u2194 fills across chains\r\n        -- Cast via NUMERIC first to handle decimal strings like \"12345.0\" from ETL\r\n        (topic_deposit_id::NUMERIC)::BIGINT AS deposit_id,\r\n        \r\n        -- Relayer address: Who provided the liquidity\r\n        -- Already decoded by ETL to proper address format (0x...)\r\n        topic_relayer AS relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- TOKEN INFORMATION (what was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input token: The token address on the origin chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Example: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 = USDC on Ethereum\r\n        filled_relay_data_input_token AS input_token_address,\r\n        \r\n        -- Output token: The token address on the destination chain (Monad in this case)\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_output_token AS output_token_address,\r\n        \r\n        -- ============================================================\r\n        -- AMOUNT INFORMATION (how much was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input amount: How much was sent from origin chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        filled_relay_data_input_amount::NUMERIC AS input_amount,\r\n        \r\n        -- Output amount: How much was received on destination chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Usually slightly less than input due to fees/spread\r\n        filled_relay_data_output_amount::NUMERIC AS output_amount,\r\n        \r\n        -- ============================================================\r\n        -- RELAYER & ROUTING INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Repayment chain ID: Where the relayer gets reimbursed\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Relayers front capital, then get paid back (often on a different chain)\r\n        -- Cast via NUMERIC first to handle decimal strings like \"1.0\" from ETL\r\n        (filled_relay_data_repayment_chain_id::NUMERIC)::BIGINT AS repayment_chain_id,\r\n        \r\n        -- Exclusive relayer: If set, only this address can fill this deposit\r\n        -- Already decoded by ETL to proper address format\r\n        -- Used for priority/guaranteed fills (NULL if no exclusive relayer)\r\n        filled_relay_data_exclusive_relayer AS exclusive_relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- USER INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Depositor: The original user who initiated the bridge\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_depositor AS depositor_address,\r\n        \r\n        -- Recipient: Who receives the funds on the destination chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Usually the same as depositor, but can be different (gift/transfer)\r\n        filled_relay_data_recipient AS recipient_address\r\n        \r\n    FROM raw_fills\r\n)\r\n\r\n-- Final SELECT: Add any computed fields and ensure data quality\r\nSELECT\r\n    -- Event identity\r\n    fill_timestamp,\r\n    transaction_hash,\r\n    blockchain,\r\n    source_file,\r\n    \r\n    -- Indexed fields\r\n    origin_chain_id,\r\n    deposit_id,\r\n    relayer_address,\r\n    \r\n    -- Token info\r\n    input_token_address,\r\n    output_token_address,\r\n    \r\n    -- Amounts\r\n    input_amount,\r\n    output_amount,\r\n    \r\n    -- Relayer routing\r\n    repayment_chain_id,\r\n    exclusive_relayer_address,\r\n    \r\n    -- User info\r\n    depositor_address,\r\n    recipient_address\r\n    \r\nFROM cleaned_fills\r\n\r\n-- Data quality: Only include rows with essential fields populated\r\nWHERE deposit_id IS NOT NULL\r\n    AND relayer_address IS NOT NULL\r\n    AND input_token_address IS NOT NULL\r\n    AND output_token_address IS NOT NULL\r\n    AND input_amount IS NOT NULL\r\n    AND output_amount IS NOT NULL", "relation_name": "\"across_analytics\".\"staging\".\"stg_monad__fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-12T12:59:01.075879Z", "completed_at": "2025-12-12T12:59:01.103881Z"}, {"name": "execute", "started_at": "2025-12-12T12:59:01.108756Z", "completed_at": "2025-12-12T12:59:01.470440Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.4154953956604004, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.stg_polygon__fills", "compiled": true, "compiled_code": "-- Staging model for FilledRelay events from Polygon\r\n\r\nWITH raw_fills AS (\r\n\r\n    SELECT\r\n        -- Core event metadata - these identify WHEN and WHERE the event happened\r\n        timestamp_datetime,              -- When the event occurred (from blockchain)\r\n        transactionHash,                 -- Unique transaction identifier\r\n        blockchain,                      -- Which blockchain (should be 'polygon')\r\n        source_file,                     -- Which source file this came from (for lineage)\r\n        \r\n        -- Indexed fields from topics (these are searchable/filterable in blockchain)\r\n        -- Topics are like \"indexed columns\" in SQL - they're stored separately for fast queries\r\n        topic_origin_chain_id,           -- Chain ID where the original deposit happened\r\n        topic_deposit_id,                -- Unique deposit identifier (links to deposit event)\r\n        topic_relayer,                   -- Address of the relayer who provided liquidity\r\n        \r\n        -- Non-indexed fields from the event's data field\r\n        -- These are the actual business data about the fill\r\n        filled_relay_data_input_token,          -- Token address on origin chain\r\n        filled_relay_data_output_token,          -- Token address on destination chain\r\n        filled_relay_data_input_amount,          -- Amount sent (in origin token units)\r\n        filled_relay_data_output_amount,         -- Amount received (in destination token units)\r\n        filled_relay_data_repayment_chain_id,     -- Where relayer gets reimbursed\r\n        filled_relay_data_exclusive_relayer,     -- Address with exclusive fill rights (if any)\r\n        filled_relay_data_depositor,             -- Original user who initiated the bridge\r\n        filled_relay_data_recipient              -- Final recipient of the bridged funds\r\n        \r\n    FROM raw.polygon_logs_processed\r\n    \r\n    -- Filter: Only include rows where FilledRelay data exists\r\n    WHERE topic_0 = '0x44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208'\r\n        AND filled_relay_data_input_amount IS NOT NULL\r\n        AND filled_relay_data_output_amount IS NOT NULL\r\n),\r\n\r\ncleaned_fills AS (\r\n    SELECT\r\n        \r\n        -- Timestamp: Convert text to proper timestamp type\r\n        \r\n        CASE \r\n            WHEN timestamp_datetime ~ '^\\d+$' THEN          -- If it's pure digits, treat as Unix timestamp (seconds since 1970-01-01)\r\n                TO_TIMESTAMP(timestamp_datetime::BIGINT)    -- PostgreSQL's TO_TIMESTAMP can parse various formats, but we use the simplest approach\r\n            ELSE \r\n                timestamp_datetime::TIMESTAMP               -- Otherwise, try to parse as ISO format string\r\n        END AS fill_timestamp,\r\n        \r\n        transactionHash AS transaction_hash,\r\n        blockchain,\r\n        source_file,\r\n        \r\n        -- ============================================================\r\n        -- INDEXED FIELDS (from topics) - Already decoded by ETL\r\n        -- ============================================================\r\n        -- These come from the event's \"topics\" array, which is indexed for fast blockchain queries\r\n        \r\n        -- Origin chain ID: Which blockchain the funds came FROM\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- Example: 1 = Ethereum, 42161 = Arbitrum, 8453 = Base\r\n        -- Cast via NUMERIC first to handle decimal strings like \"8453.0\" from ETL\r\n        (topic_origin_chain_id::NUMERIC)::BIGINT AS origin_chain_id,\r\n        \r\n        -- Deposit ID: Unique identifier linking this fill to its original deposit\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- This is the KEY that connects deposits \u2194 fills across chains\r\n        -- Cast via NUMERIC first to handle decimal strings like \"12345.0\" from ETL\r\n        (topic_deposit_id::NUMERIC)::BIGINT AS deposit_id,\r\n        \r\n        -- Relayer address: Who provided the liquidity\r\n        -- Already decoded by ETL to proper address format (0x...)\r\n        topic_relayer AS relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- TOKEN INFORMATION (what was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input token: The token address on the origin chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Example: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 = USDC on Ethereum\r\n        filled_relay_data_input_token AS input_token_address,\r\n        \r\n        -- Output token: The token address on the destination chain (Polygon in this case)\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_output_token AS output_token_address,\r\n        \r\n        -- ============================================================\r\n        -- AMOUNT INFORMATION (how much was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input amount: How much was sent from origin chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        filled_relay_data_input_amount::NUMERIC AS input_amount,\r\n        \r\n        -- Output amount: How much was received on destination chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Usually slightly less than input due to fees/spread\r\n        filled_relay_data_output_amount::NUMERIC AS output_amount,\r\n        \r\n        -- ============================================================\r\n        -- RELAYER & ROUTING INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Repayment chain ID: Where the relayer gets reimbursed\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Relayers front capital, then get paid back (often on a different chain)\r\n        -- Cast via NUMERIC first to handle decimal strings like \"1.0\" from ETL\r\n        (filled_relay_data_repayment_chain_id::NUMERIC)::BIGINT AS repayment_chain_id,\r\n        \r\n        -- Exclusive relayer: If set, only this address can fill this deposit\r\n        -- Already decoded by ETL to proper address format\r\n        -- Used for priority/guaranteed fills (NULL if no exclusive relayer)\r\n        filled_relay_data_exclusive_relayer AS exclusive_relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- USER INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Depositor: The original user who initiated the bridge\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_depositor AS depositor_address,\r\n        \r\n        -- Recipient: Who receives the funds on the destination chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Usually the same as depositor, but can be different (gift/transfer)\r\n        filled_relay_data_recipient AS recipient_address\r\n        \r\n    FROM raw_fills\r\n)\r\n\r\n-- Final SELECT: Add any computed fields and ensure data quality\r\nSELECT\r\n    -- Event identity\r\n    fill_timestamp,\r\n    transaction_hash,\r\n    blockchain,\r\n    source_file,\r\n    \r\n    -- Indexed fields\r\n    origin_chain_id,\r\n    deposit_id,\r\n    relayer_address,\r\n    \r\n    -- Token info\r\n    input_token_address,\r\n    output_token_address,\r\n    \r\n    -- Amounts\r\n    input_amount,\r\n    output_amount,\r\n    \r\n    -- Relayer routing\r\n    repayment_chain_id,\r\n    exclusive_relayer_address,\r\n    \r\n    -- User info\r\n    depositor_address,\r\n    recipient_address\r\n    \r\nFROM cleaned_fills\r\n\r\n-- Data quality: Only include rows with essential fields populated\r\nWHERE deposit_id IS NOT NULL\r\n    AND relayer_address IS NOT NULL\r\n    AND input_token_address IS NOT NULL\r\n    AND output_token_address IS NOT NULL\r\n    AND input_amount IS NOT NULL\r\n    AND output_amount IS NOT NULL", "relation_name": "\"across_analytics\".\"staging\".\"stg_polygon__fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-12T12:59:01.119922Z", "completed_at": "2025-12-12T12:59:01.130023Z"}, {"name": "execute", "started_at": "2025-12-12T12:59:01.133391Z", "completed_at": "2025-12-12T12:59:01.473743Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.38393282890319824, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.stg_worldchain__fills", "compiled": true, "compiled_code": "-- Staging model for FilledRelay events from Worldchain\r\n\r\nWITH raw_fills AS (\r\n\r\n    SELECT\r\n        -- Core event metadata - these identify WHEN and WHERE the event happened\r\n        timestamp_datetime,              -- When the event occurred (from blockchain)\r\n        transactionHash,                 -- Unique transaction identifier\r\n        blockchain,                      -- Which blockchain (should be 'worldchain')\r\n        source_file,                     -- Which source file this came from (for lineage)\r\n        \r\n        -- Indexed fields from topics (these are searchable/filterable in blockchain)\r\n        -- Topics are like \"indexed columns\" in SQL - they're stored separately for fast queries\r\n        topic_origin_chain_id,           -- Chain ID where the original deposit happened\r\n        topic_deposit_id,                -- Unique deposit identifier (links to deposit event)\r\n        topic_relayer,                   -- Address of the relayer who provided liquidity\r\n        \r\n        -- Non-indexed fields from the event's data field\r\n        -- These are the actual business data about the fill\r\n        filled_relay_data_input_token,          -- Token address on origin chain\r\n        filled_relay_data_output_token,          -- Token address on destination chain\r\n        filled_relay_data_input_amount,          -- Amount sent (in origin token units)\r\n        filled_relay_data_output_amount,         -- Amount received (in destination token units)\r\n        filled_relay_data_repayment_chain_id,     -- Where relayer gets reimbursed\r\n        filled_relay_data_exclusive_relayer,     -- Address with exclusive fill rights (if any)\r\n        filled_relay_data_depositor,             -- Original user who initiated the bridge\r\n        filled_relay_data_recipient              -- Final recipient of the bridged funds\r\n        \r\n    FROM raw.worldchain_logs_processed\r\n    \r\n    -- Filter: Only include rows where FilledRelay data exists\r\n    WHERE topic_0 = '0x44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208'\r\n        AND filled_relay_data_input_amount IS NOT NULL\r\n        AND filled_relay_data_output_amount IS NOT NULL\r\n),\r\n\r\ncleaned_fills AS (\r\n    SELECT\r\n        \r\n        -- Timestamp: Convert text to proper timestamp type\r\n        \r\n        CASE \r\n            WHEN timestamp_datetime ~ '^\\d+$' THEN          -- If it's pure digits, treat as Unix timestamp (seconds since 1970-01-01)\r\n                TO_TIMESTAMP(timestamp_datetime::BIGINT)    -- PostgreSQL's TO_TIMESTAMP can parse various formats, but we use the simplest approach\r\n            ELSE \r\n                timestamp_datetime::TIMESTAMP               -- Otherwise, try to parse as ISO format string\r\n        END AS fill_timestamp,\r\n        \r\n        transactionHash AS transaction_hash,\r\n        blockchain,\r\n        source_file,\r\n        \r\n        -- ============================================================\r\n        -- INDEXED FIELDS (from topics) - Already decoded by ETL\r\n        -- ============================================================\r\n        -- These come from the event's \"topics\" array, which is indexed for fast blockchain queries\r\n        \r\n        -- Origin chain ID: Which blockchain the funds came FROM\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- Example: 1 = Ethereum, 42161 = Arbitrum, 8453 = Base\r\n        -- Cast via NUMERIC first to handle decimal strings like \"8453.0\" from ETL\r\n        (topic_origin_chain_id::NUMERIC)::BIGINT AS origin_chain_id,\r\n        \r\n        -- Deposit ID: Unique identifier linking this fill to its original deposit\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- This is the KEY that connects deposits \u2194 fills across chains\r\n        -- Cast via NUMERIC first to handle decimal strings like \"12345.0\" from ETL\r\n        (topic_deposit_id::NUMERIC)::BIGINT AS deposit_id,\r\n        \r\n        -- Relayer address: Who provided the liquidity\r\n        -- Already decoded by ETL to proper address format (0x...)\r\n        topic_relayer AS relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- TOKEN INFORMATION (what was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input token: The token address on the origin chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Example: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 = USDC on Ethereum\r\n        filled_relay_data_input_token AS input_token_address,\r\n        \r\n        -- Output token: The token address on the destination chain (Worldchain in this case)\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_output_token AS output_token_address,\r\n        \r\n        -- ============================================================\r\n        -- AMOUNT INFORMATION (how much was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input amount: How much was sent from origin chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        filled_relay_data_input_amount::NUMERIC AS input_amount,\r\n        \r\n        -- Output amount: How much was received on destination chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Usually slightly less than input due to fees/spread\r\n        filled_relay_data_output_amount::NUMERIC AS output_amount,\r\n        \r\n        -- ============================================================\r\n        -- RELAYER & ROUTING INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Repayment chain ID: Where the relayer gets reimbursed\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Relayers front capital, then get paid back (often on a different chain)\r\n        -- Cast via NUMERIC first to handle decimal strings like \"1.0\" from ETL\r\n        (filled_relay_data_repayment_chain_id::NUMERIC)::BIGINT AS repayment_chain_id,\r\n        \r\n        -- Exclusive relayer: If set, only this address can fill this deposit\r\n        -- Already decoded by ETL to proper address format\r\n        -- Used for priority/guaranteed fills (NULL if no exclusive relayer)\r\n        filled_relay_data_exclusive_relayer AS exclusive_relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- USER INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Depositor: The original user who initiated the bridge\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_depositor AS depositor_address,\r\n        \r\n        -- Recipient: Who receives the funds on the destination chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Usually the same as depositor, but can be different (gift/transfer)\r\n        filled_relay_data_recipient AS recipient_address\r\n        \r\n    FROM raw_fills\r\n)\r\n\r\n-- Final SELECT: Add any computed fields and ensure data quality\r\nSELECT\r\n    -- Event identity\r\n    fill_timestamp,\r\n    transaction_hash,\r\n    blockchain,\r\n    source_file,\r\n    \r\n    -- Indexed fields\r\n    origin_chain_id,\r\n    deposit_id,\r\n    relayer_address,\r\n    \r\n    -- Token info\r\n    input_token_address,\r\n    output_token_address,\r\n    \r\n    -- Amounts\r\n    input_amount,\r\n    output_amount,\r\n    \r\n    -- Relayer routing\r\n    repayment_chain_id,\r\n    exclusive_relayer_address,\r\n    \r\n    -- User info\r\n    depositor_address,\r\n    recipient_address\r\n    \r\nFROM cleaned_fills\r\n\r\n-- Data quality: Only include rows with essential fields populated\r\nWHERE deposit_id IS NOT NULL\r\n    AND relayer_address IS NOT NULL\r\n    AND input_token_address IS NOT NULL\r\n    AND output_token_address IS NOT NULL\r\n    AND input_amount IS NOT NULL\r\n    AND output_amount IS NOT NULL", "relation_name": "\"across_analytics\".\"staging\".\"stg_worldchain__fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-12T12:59:01.097154Z", "completed_at": "2025-12-12T12:59:01.141586Z"}, {"name": "execute", "started_at": "2025-12-12T12:59:01.144547Z", "completed_at": "2025-12-12T12:59:01.477077Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.3912537097930908, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.stg_unichain__fills", "compiled": true, "compiled_code": "-- Staging model for FilledRelay events from Unichain\r\n\r\nWITH raw_fills AS (\r\n\r\n    SELECT\r\n        -- Core event metadata - these identify WHEN and WHERE the event happened\r\n        timestamp_datetime,              -- When the event occurred (from blockchain)\r\n        transactionHash,                 -- Unique transaction identifier\r\n        blockchain,                      -- Which blockchain (should be 'unichain')\r\n        source_file,                     -- Which source file this came from (for lineage)\r\n        \r\n        -- Indexed fields from topics (these are searchable/filterable in blockchain)\r\n        -- Topics are like \"indexed columns\" in SQL - they're stored separately for fast queries\r\n        topic_origin_chain_id,           -- Chain ID where the original deposit happened\r\n        topic_deposit_id,                -- Unique deposit identifier (links to deposit event)\r\n        topic_relayer,                   -- Address of the relayer who provided liquidity\r\n        \r\n        -- Non-indexed fields from the event's data field\r\n        -- These are the actual business data about the fill\r\n        filled_relay_data_input_token,          -- Token address on origin chain\r\n        filled_relay_data_output_token,          -- Token address on destination chain\r\n        filled_relay_data_input_amount,          -- Amount sent (in origin token units)\r\n        filled_relay_data_output_amount,         -- Amount received (in destination token units)\r\n        filled_relay_data_repayment_chain_id,     -- Where relayer gets reimbursed\r\n        filled_relay_data_exclusive_relayer,     -- Address with exclusive fill rights (if any)\r\n        filled_relay_data_depositor,             -- Original user who initiated the bridge\r\n        filled_relay_data_recipient              -- Final recipient of the bridged funds\r\n        \r\n    FROM raw.unichain_logs_processed\r\n    \r\n    -- Filter: Only include rows where FilledRelay data exists\r\n    WHERE topic_0 = '0x44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208'\r\n        AND filled_relay_data_input_amount IS NOT NULL\r\n        AND filled_relay_data_output_amount IS NOT NULL\r\n),\r\n\r\ncleaned_fills AS (\r\n    SELECT\r\n        \r\n        -- Timestamp: Convert text to proper timestamp type\r\n        \r\n        CASE \r\n            WHEN timestamp_datetime ~ '^\\d+$' THEN          -- If it's pure digits, treat as Unix timestamp (seconds since 1970-01-01)\r\n                TO_TIMESTAMP(timestamp_datetime::BIGINT)    -- PostgreSQL's TO_TIMESTAMP can parse various formats, but we use the simplest approach\r\n            ELSE \r\n                timestamp_datetime::TIMESTAMP               -- Otherwise, try to parse as ISO format string\r\n        END AS fill_timestamp,\r\n        \r\n        transactionHash AS transaction_hash,\r\n        blockchain,\r\n        source_file,\r\n        \r\n        -- ============================================================\r\n        -- INDEXED FIELDS (from topics) - Already decoded by ETL\r\n        -- ============================================================\r\n        -- These come from the event's \"topics\" array, which is indexed for fast blockchain queries\r\n        \r\n        -- Origin chain ID: Which blockchain the funds came FROM\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- Example: 1 = Ethereum, 42161 = Arbitrum, 8453 = Base\r\n        -- Cast via NUMERIC first to handle decimal strings like \"8453.0\" from ETL\r\n        (topic_origin_chain_id::NUMERIC)::BIGINT AS origin_chain_id,\r\n        \r\n        -- Deposit ID: Unique identifier linking this fill to its original deposit\r\n        -- Already converted by ETL from hex to integer (stored as text in raw table)\r\n        -- This is the KEY that connects deposits \u2194 fills across chains\r\n        -- Cast via NUMERIC first to handle decimal strings like \"12345.0\" from ETL\r\n        (topic_deposit_id::NUMERIC)::BIGINT AS deposit_id,\r\n        \r\n        -- Relayer address: Who provided the liquidity\r\n        -- Already decoded by ETL to proper address format (0x...)\r\n        topic_relayer AS relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- TOKEN INFORMATION (what was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input token: The token address on the origin chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Example: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 = USDC on Ethereum\r\n        filled_relay_data_input_token AS input_token_address,\r\n        \r\n        -- Output token: The token address on the destination chain (Unichain in this case)\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_output_token AS output_token_address,\r\n        \r\n        -- ============================================================\r\n        -- AMOUNT INFORMATION (how much was bridged)\r\n        -- ============================================================\r\n        \r\n        -- Input amount: How much was sent from origin chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        filled_relay_data_input_amount::NUMERIC AS input_amount,\r\n        \r\n        -- Output amount: How much was received on destination chain\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Usually slightly less than input due to fees/spread\r\n        filled_relay_data_output_amount::NUMERIC AS output_amount,\r\n        \r\n        -- ============================================================\r\n        -- RELAYER & ROUTING INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Repayment chain ID: Where the relayer gets reimbursed\r\n        -- Already converted by ETL from hex to numeric (stored as text in raw table)\r\n        -- Relayers front capital, then get paid back (often on a different chain)\r\n        -- Cast via NUMERIC first to handle decimal strings like \"1.0\" from ETL\r\n        (filled_relay_data_repayment_chain_id::NUMERIC)::BIGINT AS repayment_chain_id,\r\n        \r\n        -- Exclusive relayer: If set, only this address can fill this deposit\r\n        -- Already decoded by ETL to proper address format\r\n        -- Used for priority/guaranteed fills (NULL if no exclusive relayer)\r\n        filled_relay_data_exclusive_relayer AS exclusive_relayer_address,\r\n        \r\n        -- ============================================================\r\n        -- USER INFORMATION\r\n        -- ============================================================\r\n        \r\n        -- Depositor: The original user who initiated the bridge\r\n        -- Already decoded by ETL to proper address format\r\n        filled_relay_data_depositor AS depositor_address,\r\n        \r\n        -- Recipient: Who receives the funds on the destination chain\r\n        -- Already decoded by ETL to proper address format\r\n        -- Usually the same as depositor, but can be different (gift/transfer)\r\n        filled_relay_data_recipient AS recipient_address\r\n        \r\n    FROM raw_fills\r\n)\r\n\r\n-- Final SELECT: Add any computed fields and ensure data quality\r\nSELECT\r\n    -- Event identity\r\n    fill_timestamp,\r\n    transaction_hash,\r\n    blockchain,\r\n    source_file,\r\n    \r\n    -- Indexed fields\r\n    origin_chain_id,\r\n    deposit_id,\r\n    relayer_address,\r\n    \r\n    -- Token info\r\n    input_token_address,\r\n    output_token_address,\r\n    \r\n    -- Amounts\r\n    input_amount,\r\n    output_amount,\r\n    \r\n    -- Relayer routing\r\n    repayment_chain_id,\r\n    exclusive_relayer_address,\r\n    \r\n    -- User info\r\n    depositor_address,\r\n    recipient_address\r\n    \r\nFROM cleaned_fills\r\n\r\n-- Data quality: Only include rows with essential fields populated\r\nWHERE deposit_id IS NOT NULL\r\n    AND relayer_address IS NOT NULL\r\n    AND input_token_address IS NOT NULL\r\n    AND output_token_address IS NOT NULL\r\n    AND input_amount IS NOT NULL\r\n    AND output_amount IS NOT NULL", "relation_name": "\"across_analytics\".\"staging\".\"stg_unichain__fills\"", "batch_results": null}], "elapsed_time": 1.4797654151916504, "args": {"validate_macro_args": false, "exclude": [], "indirect_selection": "eager", "introspect": true, "log_level": "info", "require_generic_test_arguments_property": true, "select": ["staging.*.*__fills"], "warn_error_options": {"error": [], "warn": [], "silence": []}, "show_all_deprecations": false, "log_path": "C:\\Users\\Longin\\Desktop\\Projects\\across_analytics\\logs", "use_colors_file": true, "which": "run", "log_file_max_bytes": 10485760, "state_modified_compare_more_unrendered_values": false, "upload_to_artifacts_ingest_api": false, "send_anonymous_usage_stats": true, "invocation_command": "dbt run --select staging.*.*__fills", "project_dir": "C:\\Users\\Longin\\Desktop\\Projects\\across_analytics", "use_colors": true, "quiet": false, "printer_width": 80, "use_fast_test_edges": false, "source_freshness_run_project_hooks": true, "macro_debugging": false, "log_format": "default", "partial_parse_file_diff": true, "skip_nodes_if_on_run_start_fails": false, "log_level_file": "debug", "require_explicit_package_overrides_for_builtin_materializations": true, "require_all_warnings_handled_by_warn_error": false, "require_nested_cumulative_type_params": false, "require_yaml_configuration_for_mf_time_spines": false, "strict_mode": false, "version_check": true, "partial_parse": true, "log_format_file": "debug", "static_parser": true, "require_resource_names_without_spaces": true, "state_modified_compare_vars": false, "vars": {}, "cache_selected_only": false, "write_json": true, "require_batched_execution_for_custom_microbatch_strategy": false, "profiles_dir": "C:\\Users\\Longin\\.dbt", "defer": false, "empty": false, "populate_cache": true, "show_resource_report": false, "favor_state": false, "print": true}}