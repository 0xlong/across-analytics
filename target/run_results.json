{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.10.15", "generated_at": "2026-01-07T16:44:26.739152Z", "invocation_id": "29603cfe-fe78-48ff-889f-ead47efd29bf", "invocation_started_at": "2026-01-07T16:44:19.833732Z", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-07T16:44:23.176896Z", "completed_at": "2026-01-07T16:44:23.226179Z"}, {"name": "execute", "started_at": "2026-01-07T16:44:23.227477Z", "completed_at": "2026-01-07T16:44:23.604627Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.44690990447998047, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_refunds_expanded", "compiled": true, "compiled_code": "-- int_refunds_expanded.sql\n-- CHALLENGE: some refund_amounts_string are arrays that have to be unnested\n-- PURPOSE: Expand comma-separated refund arrays into individual rows\n-- WHY: Each row = one relayer receiving one refund amount\n-- ENABLES: Easy aggregation, filtering by relayer, joins with relayer metrics\n\n\n\nWITH unified AS (\n    -- Get all refunds from all chains (already unified in int_unified_refunds)\n    SELECT * \n    FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_refunds\"\n    WHERE refund_count > 0  -- Only process batches with actual refunds\n),\n\n-- Hourly token prices for USD conversion\ntoken_prices AS (\n    SELECT \n        token_symbol,\n        DATE_TRUNC('hour', timestamp::TIMESTAMP) AS price_hour,\n        AVG(price_usd) AS price_usd\n    FROM \"across_analytics\".\"dbt\".\"token_prices\"\n    GROUP BY token_symbol, DATE_TRUNC('hour', timestamp::TIMESTAMP)\n),\n\n-- Unnest the comma-separated strings into individual rows\n-- Uses CROSS JOIN LATERAL with UNNEST to expand arrays\n-- WITH ORDINALITY gives us the position index for matching amounts to addresses\nexpanded AS (\n    SELECT\n        -- Batch-level identifiers (same for all rows from same batch)\n        refund_timestamp,\n        transaction_hash,\n        chain_id,\n        chain_name,\n        root_bundle_id,\n        leaf_id,\n        refund_token_address,\n        refund_token_symbol,\n        token_decimals,\n        total_refund_amount,\n        total_refund_amount_raw,\n        refund_count,\n        source_blockchain,\n        \n        -- Individual refund data (one row per relayer/amount pair)\n        -- TRIM handles any whitespace that might exist in the CSV-like strings\n        TRIM(amounts.amount)::NUMERIC AS refund_amount_raw,\n        TRIM(addresses.address) AS relayer_address,\n        amounts.idx AS refund_index\n        \n    FROM unified\n    -- Expand refund_amounts_string: \"100,200,300\" \u2192 3 rows with values 100, 200, 300\n    CROSS JOIN LATERAL UNNEST(\n        string_to_array(refund_amounts_string, ',')\n    ) WITH ORDINALITY AS amounts(amount, idx)\n    -- Expand refund_addresses_string: \"0xAAA,0xBBB,0xCCC\" \u2192 3 rows with addresses\n    CROSS JOIN LATERAL UNNEST(\n        string_to_array(refund_addresses_string, ',')\n    ) WITH ORDINALITY AS addresses(address, idx)\n    -- Match by position: 1st amount goes to 1st address, 2nd to 2nd, etc.\n    WHERE amounts.idx = addresses.idx\n)\n\nSELECT\n    -- Event identification\n    e.refund_timestamp,\n    e.transaction_hash,\n    e.source_blockchain,\n    \n    -- Batch identifiers (for grouping back if needed)\n    e.chain_id,\n    e.chain_name,\n    e.root_bundle_id,\n    e.leaf_id,\n    \n    -- Individual refund details\n    e.refund_index,\n    e.relayer_address,\n    e.refund_token_address,\n    e.refund_token_symbol,\n    \n    -- Individual refund amount (rescaled using token decimals)\n    \n    e.refund_amount_raw / POWER(10, COALESCE(e.token_decimals, 18))\n AS refund_amount,\n    e.refund_amount_raw,\n    \n    -- USD price data\n    tp.price_usd AS refund_token_price_usd,\n    ROUND((\n    e.refund_amount_raw / POWER(10, COALESCE(e.token_decimals, 18))\n * COALESCE(tp.price_usd, 1))::NUMERIC, 2) AS refund_amount_usd,\n    \n    -- Batch context (useful for analysis)\n    e.total_refund_amount AS batch_total_amount,\n    e.total_refund_amount_raw AS batch_total_amount_raw,\n    e.refund_count AS batch_refund_count,\n    \n    -- Unique identifier for each individual refund record\n    e.transaction_hash || '-' || e.leaf_id || '-' || e.refund_index AS refund_id\n    \nFROM expanded e\n-- Join for refund token price at refund hour\nLEFT JOIN token_prices tp\n    ON e.refund_token_symbol = tp.token_symbol\n    AND DATE_TRUNC('hour', e.refund_timestamp) = tp.price_hour", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_refunds_expanded\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-07T16:44:23.213101Z", "completed_at": "2026-01-07T16:44:23.323986Z"}, {"name": "execute", "started_at": "2026-01-07T16:44:23.325184Z", "completed_at": "2026-01-07T16:44:23.631536Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.43783044815063477, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_fills", "compiled": true, "compiled_code": "-- int_unified_fills.sql\n-- PURPOSE: Combine fills from ALL chains into ONE table\n-- WHY: Fills happen on the DESTINATION chain. We need to see all fills to match with deposits.\n\n\n\n-- Each CTE selects from a chain's staging model and adds the destination chain ID\nWITH arbitrum_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        42161 AS destination_chain_id,  -- Fill happened ON Arbitrum\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_arbitrum__fills\"\n),\n\nethereum_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        1 AS destination_chain_id,  -- Fill happened ON Ethereum\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_ethereum__fills\"\n),\n\npolygon_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        137 AS destination_chain_id,  -- Fill happened ON Polygon\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_polygon__fills\"\n),\n\nlinea_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        59144 AS destination_chain_id,  -- Fill happened ON Linea\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_linea__fills\"\n),\n\nworldchain_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        480 AS destination_chain_id,  -- Fill happened ON WorldChain\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_worldchain__fills\"\n),\n\nunichain_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        130 AS destination_chain_id,  -- Fill happened ON Unichain\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_unichain__fills\"\n),\n\nhyperevm_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        999 AS destination_chain_id,  -- Fill happened ON HyperEVM\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_hyperevm__fills\"\n),\n\nmonad_fills AS (\n    SELECT \n        fill_timestamp,\n        transaction_hash,\n        origin_chain_id,\n        143 AS destination_chain_id,  -- Fill happened ON Monad\n        deposit_id,\n        relayer_address,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount,\n        repayment_chain_id,\n        gas_price_wei,\n        gas_used,\n        gas_cost_wei\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_monad__fills\"\n),\n\n-- Supported chain IDs (chains we have parquet data for)\n-- 42161=Arbitrum, 1=Ethereum, 137=Polygon, 59144=Linea, 480=Worldchain, 130=Unichain, 999=HyperEVM, 143=Monad\n\n-- Chain ID to Name mapping for chains with parquet data\nchain_names AS (\n    SELECT chain_id, chain_name\n    FROM (\n        VALUES\n        (1, 'Ethereum'), (42161, 'Arbitrum'), (137, 'Polygon'),\n        (59144, 'Linea'), (480, 'Worldchain'), (130, 'Unichain'),\n        (999, 'HyperEVM'), (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Hourly token prices for USD conversion\ntoken_prices AS (\n    SELECT \n        token_symbol,\n        DATE_TRUNC('hour', timestamp::TIMESTAMP) AS price_hour,\n        AVG(price_usd) AS price_usd\n    FROM \"across_analytics\".\"dbt\".\"token_prices\"\n    GROUP BY token_symbol, DATE_TRUNC('hour', timestamp::TIMESTAMP)\n),\n\n-- UNION ALL: Stack all fills from all chains into one table\n-- Filter: Only include fills where origin_chain_id is a supported chain\nall_fills AS (\n    SELECT * FROM arbitrum_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM ethereum_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM polygon_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM linea_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM worldchain_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM unichain_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM hyperevm_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM monad_fills WHERE origin_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n)\n\n-- Final SELECT with descriptive chain names and USD amounts\nSELECT\n    f.fill_timestamp,\n    f.transaction_hash,\n    f.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    f.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    f.deposit_id,\n    f.relayer_address,\n    f.depositor_address,\n    f.recipient_address,\n    f.input_token_address,\n    f.output_token_address,\n    f.output_token_symbol AS fill_token_symbol,  -- Token symbol for the filled amount\n    f.input_amount,\n    f.output_amount,\n    f.repayment_chain_id,\n    -- Gas data (for relayer cost analysis)\n    f.gas_price_wei,\n    f.gas_used,\n    f.gas_cost_wei,\n    -- USD price data\n    tp.price_usd AS output_token_price_usd,\n    ROUND((f.output_amount * COALESCE(tp.price_usd, 1))::NUMERIC, 2) AS output_amount_usd\nFROM all_fills f\nLEFT JOIN chain_names oc ON f.origin_chain_id = oc.chain_id\nLEFT JOIN chain_names dc ON f.destination_chain_id = dc.chain_id\n-- Join for output token price at fill hour\nLEFT JOIN token_prices tp\n    ON f.output_token_symbol = tp.token_symbol\n    AND DATE_TRUNC('hour', f.fill_timestamp) = tp.price_hour", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_fills\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-07T16:44:23.202173Z", "completed_at": "2026-01-07T16:44:23.256938Z"}, {"name": "execute", "started_at": "2026-01-07T16:44:23.258185Z", "completed_at": "2026-01-07T16:44:23.635984Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.4619731903076172, "adapter_response": {"_message": "CREATE VIEW", "code": "CREATE VIEW", "rows_affected": -1}, "message": "CREATE VIEW", "failures": null, "unique_id": "model.across_analytics.int_unified_deposits", "compiled": true, "compiled_code": "-- int_unified_deposits.sql\n-- PURPOSE: Combine deposits from ALL chains into ONE table\n-- WHY: Right now deposits are separate per chain. We need them unified to track cross-chain flows.\n\n\n\n-- Each CTE selects from a chain's staging model and adds the origin chain ID\nWITH arbitrum_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        42161 AS origin_chain_id,  -- Arbitrum's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_arbitrum__deposits\"\n),\n\nethereum_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        1 AS origin_chain_id,  -- Ethereum's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_ethereum__deposits\"\n),\n\npolygon_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        137 AS origin_chain_id,  -- Polygon's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_polygon__deposits\"\n),\n\nlinea_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        59144 AS origin_chain_id,  -- Linea's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_linea__deposits\"\n),\n\nworldchain_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        480 AS origin_chain_id,  -- WorldChain's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_worldchain__deposits\"\n),\n\nunichain_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        130 AS origin_chain_id,  -- Unichain's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_unichain__deposits\"\n),\n\nhyperevm_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        999 AS origin_chain_id,  -- HyperEVM's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_hyperevm__deposits\"\n),\n\nmonad_deposits AS (\n    SELECT \n        deposit_timestamp,\n        transaction_hash,\n        143 AS origin_chain_id,  -- Monad's chain ID\n        destination_chain_id,\n        deposit_id,\n        depositor_address,\n        recipient_address,\n        input_token_address,\n        input_token_symbol,\n        output_token_address,\n        output_token_symbol,\n        input_amount,\n        output_amount\n    FROM \"across_analytics\".\"dbt_staging\".\"stg_monad__deposits\"\n),\n\n-- Supported chain IDs (chains we have parquet data for)\n-- 42161=Arbitrum, 1=Ethereum, 137=Polygon, 59144=Linea, 480=Worldchain, 130=Unichain, 999=HyperEVM, 143=Monad\n\n-- Chain ID to Name mapping for chains with parquet data\nchain_names AS (\n    SELECT chain_id, chain_name\n    FROM (\n        VALUES\n        (1, 'Ethereum'), (42161, 'Arbitrum'), (137, 'Polygon'),\n        (59144, 'Linea'), (480, 'Worldchain'), (130, 'Unichain'),\n        (999, 'HyperEVM'), (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Hourly token prices for USD conversion\ntoken_prices AS (\n    SELECT \n        token_symbol,\n        DATE_TRUNC('hour', timestamp::TIMESTAMP) AS price_hour,\n        AVG(price_usd) AS price_usd\n    FROM \"across_analytics\".\"dbt\".\"token_prices\"\n    GROUP BY token_symbol, DATE_TRUNC('hour', timestamp::TIMESTAMP)\n),\n\n-- UNION ALL: Stack all deposits from all chains into one table\n-- Filter: Only include deposits where destination_chain_id is a supported chain\nall_deposits AS (\n    SELECT * FROM arbitrum_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM ethereum_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM polygon_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM linea_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM worldchain_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM unichain_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM hyperevm_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n    UNION ALL\n    SELECT * FROM monad_deposits WHERE destination_chain_id IN (42161, 1, 137, 59144, 480, 130, 999, 143)\n)\n\n-- Final SELECT with descriptive chain names and USD amounts\nSELECT\n    d.deposit_timestamp,\n    d.transaction_hash,\n    d.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    d.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    d.deposit_id,\n    d.depositor_address,\n    d.recipient_address,\n    d.input_token_address,\n    d.input_token_symbol,\n    d.output_token_address,\n    d.output_token_symbol,\n    d.input_amount,\n    d.output_amount,\n    -- USD price data\n    tp.price_usd AS input_token_price_usd,\n    ROUND((d.input_amount * COALESCE(tp.price_usd, 1))::NUMERIC, 2) AS input_amount_usd\nFROM all_deposits d\nLEFT JOIN chain_names oc ON d.origin_chain_id = oc.chain_id\nLEFT JOIN chain_names dc ON d.destination_chain_id = dc.chain_id\n-- Join for input token price at deposit hour\nLEFT JOIN token_prices tp\n    ON d.input_token_symbol = tp.token_symbol\n    AND DATE_TRUNC('hour', d.deposit_timestamp) = tp.price_hour", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_unified_deposits\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-07T16:44:23.656858Z", "completed_at": "2026-01-07T16:44:23.667580Z"}, {"name": "execute", "started_at": "2026-01-07T16:44:23.669514Z", "completed_at": "2026-01-07T16:44:25.719634Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 2.067598581314087, "adapter_response": {"_message": "SELECT 4036", "code": "SELECT", "rows_affected": 4036}, "message": "SELECT 4036", "failures": null, "unique_id": "model.across_analytics.int_deposit_fill_matching", "compiled": true, "compiled_code": "-- int_deposit_fill_matching.sql\n-- PURPOSE: Match every deposit to its fill (if it exists)\n-- WHY: This is the CORE model - connects money leaving one chain to money arriving on another.\n-- \n-- HOW IT WORKS:\n-- 1. User deposits on Chain A \u2192 creates deposit_id\n-- 2. Relayer fills on Chain B \u2192 same deposit_id\n-- 3. We JOIN on deposit_id + origin/destination chain match\n-- 4. Unfilled deposits = rows with NULL fill (stuck capital)\n\n\n--  for faster superset charts loading\n\n\n-- Chain ID to Name mapping for chains with parquet data\nWITH chain_names AS (\n    SELECT \n        chain_id,\n        chain_name\n    FROM (\n        VALUES\n        -- Only chains we have parquet data for:\n        (1, 'Ethereum'),\n        (42161, 'Arbitrum'),\n        (137, 'Polygon'),\n        (59144, 'Linea'),\n        (480, 'Worldchain'),\n        (130, 'Unichain'),\n        (999, 'HyperEVM'),\n        (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Token metadata for symbol lookups\ntoken_metadata AS (\n    SELECT * FROM \"across_analytics\".\"dbt\".\"token_metadata\"\n),\n\n-- Hourly token prices for USD conversion\n-- Truncate to hour for matching with transaction timestamps\ntoken_prices AS (\n    SELECT \n        token_symbol,\n        DATE_TRUNC('hour', timestamp::TIMESTAMP) AS price_hour,\n        AVG(price_usd) AS price_usd  -- Average in case of duplicate hours\n    FROM \"across_analytics\".\"dbt\".\"token_prices\"\n    GROUP BY token_symbol, DATE_TRUNC('hour', timestamp::TIMESTAMP)\n),\n\n-- Native token symbol per chain (for gas cost USD conversion)\n-- Gas fees are paid in the chain's native token\nnative_tokens AS (\n    SELECT chain_id, native_token_symbol\n    FROM (\n        VALUES\n        (1, 'WETH'),       -- Ethereum: ETH (use WETH price)\n        (42161, 'WETH'),   -- Arbitrum: ETH\n        (137, 'POL'),      -- Polygon: POL (rebranded from MATIC)\n        (59144, 'WETH'),   -- Linea: ETH\n        (480, 'WETH'),     -- Worldchain: ETH (WLD for app, but gas in ETH)\n        (130, 'WETH'),     -- Unichain: ETH\n        (999, 'WETH'),     -- HyperEVM: ETH\n        (143, 'MON')       -- Monad: MON (native token, not ETH!)\n    ) AS nt(chain_id, native_token_symbol)\n),\n\ndeposits AS (\n    SELECT * FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_deposits\"\n),\n\nfills AS (\n    SELECT * FROM \"across_analytics\".\"dbt_intermediate\".\"int_unified_fills\"\n),\n\n-- JOIN deposits to fills on deposit_id + chain matching\nmatched AS (\n    SELECT\n        -- === DEPOSIT INFO (Origin side) ===\n        d.deposit_timestamp,\n        d.transaction_hash AS deposit_tx_hash,\n        d.origin_chain_id,\n        d.destination_chain_id,\n        d.deposit_id,\n        d.depositor_address,\n        d.recipient_address AS deposit_recipient,\n        d.input_token_address AS deposit_token,\n        d.input_amount AS deposit_amount,\n        d.output_amount AS expected_output_amount,\n        \n        -- === FILL INFO (Destination side) ===\n        f.fill_timestamp,\n        f.transaction_hash AS fill_tx_hash,\n        f.relayer_address,\n        f.output_token_address AS fill_token,\n        f.output_amount AS actual_output_amount,\n        f.repayment_chain_id,\n        \n        -- === GAS DATA (for relayer cost analysis) ===\n        f.gas_price_wei,\n        f.gas_used,\n        f.gas_cost_wei,\n        \n        -- === COMPUTED FIELDS ===\n        -- Fill latency: How long did it take to fill? (in seconds)\n        -- Use GREATEST(0, ...) to handle cross-chain timestamp sync issues\n        GREATEST(0, EXTRACT(EPOCH FROM (f.fill_timestamp - d.deposit_timestamp))) AS fill_latency_seconds,\n        \n        -- Is this deposit filled?\n        CASE WHEN f.deposit_id IS NOT NULL THEN TRUE ELSE FALSE END AS is_filled,\n        \n        -- Fee: difference between deposited amount and filled amount\n        CASE \n            WHEN f.output_amount IS NOT NULL\n            THEN ROUND((d.input_amount - f.output_amount)::NUMERIC, 2)\n            ELSE NULL \n        END AS bridge_fee_nominal,\n        \n        CASE \n            WHEN f.output_amount IS NOT NULL\n            THEN ROUND(((d.input_amount - f.output_amount) / d.input_amount * 100)::NUMERIC, 2)\n            ELSE NULL \n        END AS bridge_fee_percent,\n        \n        -- Slippage: Difference between expected and actual output\n        CASE \n            WHEN f.output_amount IS NOT NULL AND d.output_amount > 0 \n            THEN ROUND(((d.output_amount - f.output_amount) / d.output_amount * 100)::NUMERIC, 2)\n            ELSE NULL \n        END AS slippage_percent\n\n    FROM deposits d\n    \n    -- LEFT JOIN: Keep ALL deposits, even unfilled ones\n    LEFT JOIN fills f \n        ON d.deposit_id = f.deposit_id\n        AND d.origin_chain_id = f.origin_chain_id  -- Must match origin\n        AND d.destination_chain_id = f.destination_chain_id  -- Must match destination\n)\n\nSELECT\n    -- Identity\n    m.deposit_timestamp,\n    m.deposit_tx_hash,\n    m.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    m.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    m.deposit_id,\n    \n    -- Deposit details\n    m.depositor_address,\n    m.deposit_recipient,\n    m.deposit_token,\n    dt.token_symbol AS deposit_token_symbol,\n    m.deposit_amount,\n    m.expected_output_amount,\n    \n    -- USD-normalized amounts (joined from hourly price data)\n    dp.price_usd AS deposit_token_price_usd,\n    ROUND((m.deposit_amount * COALESCE(dp.price_usd, 1))::NUMERIC, 2) AS deposit_amount_usd,\n    \n    -- Fill details (NULL if unfilled)\n    m.fill_timestamp,\n    m.fill_tx_hash,\n    m.relayer_address,\n    m.fill_token,\n    ft.token_symbol AS fill_token_symbol,\n    m.actual_output_amount,\n    m.repayment_chain_id,\n    \n    -- USD-normalized fill amount\n    fp.price_usd AS fill_token_price_usd,\n    CASE \n        WHEN m.actual_output_amount IS NOT NULL \n        THEN ROUND((m.actual_output_amount * COALESCE(fp.price_usd, 1))::NUMERIC, 2)\n        ELSE NULL \n    END AS fill_amount_usd,\n    \n    -- Metrics\n    m.fill_latency_seconds,\n    m.is_filled,\n    m.bridge_fee_nominal,\n    m.bridge_fee_percent,\n    m.slippage_percent,\n    \n    -- Gas data (for relayer cost analysis)\n    -- These represent the cost incurred by the relayer on the destination chain\n    -- NOTE: Different chains use different native tokens (ETH, MATIC, WLD, etc.)\n    m.gas_price_wei,\n    m.gas_used,\n    m.gas_cost_wei,\n    -- Convert gas cost to native token units for readability (wei / 10^18)\n    ROUND((m.gas_cost_wei / 1e18)::NUMERIC, 8) AS gas_cost_native,\n    -- Gas cost in USD (using native token price at fill hour)\n    CASE \n        WHEN m.gas_cost_wei IS NOT NULL \n        THEN ROUND(((m.gas_cost_wei / 1e18) * COALESCE(np.price_usd, 0))::NUMERIC, 2)\n        ELSE NULL \n    END AS gas_cost_usd,\n    \n    -- Bridge fee in USD (fee * deposit token price)\n    CASE \n        WHEN m.bridge_fee_nominal IS NOT NULL \n        THEN ROUND((m.bridge_fee_nominal * COALESCE(dp.price_usd, 1))::NUMERIC, 2)\n        ELSE NULL \n    END AS bridge_fee_nominal_usd,\n    \n    -- Route identifier (for aggregations)\n    oc.chain_name || ' \u2192 ' || dc.chain_name AS route_name,\n    m.origin_chain_id || '_' || m.destination_chain_id AS route_id,\n    \n    -- ========================================================================\n    -- LATENCY TIER (Fill-Level Speed Classification)\n    -- ========================================================================\n    -- WHAT: Classifies EACH individual fill's speed as CRITICAL / SLOW / MODERATE / FAST\n    -- WHY:  Enables drill-down analysis of specific slow transactions.\n    --       Complements the route-level liquidity_gap_status in mart_fill_latency_analysis.\n    --\n    -- DATA-DRIVEN THRESHOLDS (based on raw fill distribution from dataset):\n    --   Distribution: median=8s, p75=15s, p95=42s\n    --\n    --   - CRITICAL: > 100s \u2192 2.5x slower than global p95, severe delay\n    --   - SLOW:     > 42s  \u2192 Exceeds global p95, investigate\n    --   - MODERATE: > 15s  \u2192 Exceeds global p75, slower than typical\n    --   - FAST:     \u2264 15s  \u2192 At or below p75, good UX\n    --\n    -- USE:  Incident investigation, outlier analysis, user experience audit.\n    -- ========================================================================\n    CASE \n        WHEN m.is_filled = FALSE THEN NULL  -- Unfilled deposits have no latency tier\n        WHEN m.fill_latency_seconds > 100 THEN 'CRITICAL'\n        WHEN m.fill_latency_seconds > 42 THEN 'SLOW'\n        WHEN m.fill_latency_seconds > 15 THEN 'MODERATE'\n        ELSE 'FAST'\n    END AS latency_tier\n\nFROM matched m\n\n-- Join for origin chain name\nLEFT JOIN chain_names oc ON m.origin_chain_id = oc.chain_id\n\n-- Join for destination chain name  \nLEFT JOIN chain_names dc ON m.destination_chain_id = dc.chain_id\n\n-- Join for deposit token symbol (origin chain token)\nLEFT JOIN token_metadata dt \n    ON m.origin_chain_id = dt.chain_id \n    AND LOWER(m.deposit_token) = LOWER(dt.token_address)\n\n-- Join for fill token symbol (destination chain token)\nLEFT JOIN token_metadata ft \n    ON m.destination_chain_id = ft.chain_id \n    AND LOWER(m.fill_token) = LOWER(ft.token_address)\n\n-- Join for deposit token price at deposit hour (convert to UTC for matching)\nLEFT JOIN token_prices dp\n    ON dt.token_symbol = dp.token_symbol\n    AND DATE_TRUNC('hour', m.deposit_timestamp AT TIME ZONE 'UTC') = dp.price_hour\n\n-- Join for fill token price at fill hour (convert to UTC for matching)\nLEFT JOIN token_prices fp\n    ON ft.token_symbol = fp.token_symbol\n    AND DATE_TRUNC('hour', m.fill_timestamp AT TIME ZONE 'UTC') = fp.price_hour\n\n-- Join for native token symbol on destination chain (for gas cost USD)\nLEFT JOIN native_tokens nt ON m.destination_chain_id = nt.chain_id\n\n-- Join for native token price at fill hour (convert to UTC for matching)\nLEFT JOIN token_prices np\n    ON nt.native_token_symbol = np.token_symbol\n    AND DATE_TRUNC('hour', m.fill_timestamp AT TIME ZONE 'UTC') = np.price_hour", "relation_name": "\"across_analytics\".\"dbt_intermediate\".\"int_deposit_fill_matching\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-07T16:44:25.815588Z", "completed_at": "2026-01-07T16:44:25.858798Z"}, {"name": "execute", "started_at": "2026-01-07T16:44:25.868057Z", "completed_at": "2026-01-07T16:44:26.176237Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.42549681663513184, "adapter_response": {"_message": "SELECT 49", "code": "SELECT", "rows_affected": 49}, "message": "SELECT 49", "failures": null, "unique_id": "model.across_analytics.mart_route_concentration_risk", "compiled": true, "compiled_code": "-- mart_route_concentration_risk.sql\n-- PURPOSE: Analyze relayer concentration risk per route using CR3 (Share of Top 3 Relayers)\n-- METRICS: Filler Dominance Index, Total Volume, Top 3 Volume\n\n\n\nWITH relayer_volume_by_route AS (\n    -- Step 1: Sum volume per relayer per route\n    SELECT \n        origin_chain_name,\n        destination_chain_name,\n        route_name,\n        relayer_address,\n        SUM(fill_amount_usd) AS relayer_volume_usd\n    FROM \"across_analytics\".\"dbt_intermediate\".\"int_deposit_fill_matching\"\n    WHERE is_filled = TRUE \n      AND relayer_address IS NOT NULL\n      AND route_name IS NOT NULL\n      AND fill_amount_usd > 0  -- Exclude zero/null amounts\n    GROUP BY origin_chain_name, destination_chain_name, route_name, relayer_address\n),\n\nranked_relayers AS (\n    -- Step 2: Rank relayers within each route by volume\n    SELECT \n        origin_chain_name,\n        destination_chain_name,\n        route_name,\n        relayer_address,\n        relayer_volume_usd,\n        ROW_NUMBER() OVER (\n            PARTITION BY route_name \n            ORDER BY relayer_volume_usd DESC\n        ) AS rank_in_route\n    FROM relayer_volume_by_route\n),\n\nroute_totals AS (\n    -- Step 3: Calculate total volume per route\n    SELECT \n        route_name,\n        SUM(relayer_volume_usd) AS total_route_volume_usd\n    FROM relayer_volume_by_route\n    GROUP BY route_name\n    HAVING SUM(relayer_volume_usd) > 0  -- Only routes with positive volume\n),\n\ntop3_volume AS (\n    -- Step 4: Sum volume of top 3 relayers per route\n    SELECT \n        origin_chain_name,\n        destination_chain_name,\n        route_name,\n        SUM(relayer_volume_usd) AS top3_volume_usd\n    FROM ranked_relayers\n    WHERE rank_in_route <= 3\n    GROUP BY origin_chain_name, destination_chain_name, route_name\n)\n\n-- Step 5: Calculate Filler Dominance Index per Route\nSELECT \n    t.origin_chain_name,\n    t.destination_chain_name,\n    t.route_name,\n    ROUND(rt.total_route_volume_usd::NUMERIC, 2) AS total_volume_usd,\n    ROUND(t.top3_volume_usd::NUMERIC, 2) AS top_3_relayer_volume_usd,\n    ROUND((t.top3_volume_usd / NULLIF(rt.total_route_volume_usd, 0) * 100)::NUMERIC, 2) \n        AS filler_dominance_index_pct,\n    -- Risk classification\n    CASE \n        WHEN rt.total_route_volume_usd = 0 OR rt.total_route_volume_usd IS NULL THEN 'NO DATA'\n        WHEN (t.top3_volume_usd / rt.total_route_volume_usd * 100) > 90 THEN 'CRITICAL'\n        WHEN (t.top3_volume_usd / rt.total_route_volume_usd * 100) > 80 THEN 'HIGH'\n        WHEN (t.top3_volume_usd / rt.total_route_volume_usd * 100) > 60 THEN 'MODERATE'\n        ELSE 'HEALTHY'\n    END AS concentration_risk\nFROM top3_volume t\nJOIN route_totals rt ON t.route_name = rt.route_name\nORDER BY filler_dominance_index_pct DESC", "relation_name": "\"across_analytics\".\"dbt_marts\".\"mart_route_concentration_risk\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-07T16:44:25.754072Z", "completed_at": "2026-01-07T16:44:25.827866Z"}, {"name": "execute", "started_at": "2026-01-07T16:44:25.830074Z", "completed_at": "2026-01-07T16:44:26.505455Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.7652206420898438, "adapter_response": {"_message": "SELECT 3760", "code": "SELECT", "rows_affected": 3760}, "message": "SELECT 3760", "failures": null, "unique_id": "model.across_analytics.mart_fill_latency_analysis", "compiled": true, "compiled_code": "-- ============================================================================\n-- mart_fill_latency_analysis.sql\n-- ============================================================================\n-- PURPOSE: Analyze Time-to-Fill (TTF) to identify filler hesitation and \n--          liquidity gaps across routes\n-- \n-- GRAIN: Minute \u00d7 Route \u00d7 Token\n-- \n-- KEY BUSINESS QUESTIONS:\n--   1. Which routes have \"Filler Hesitation\"? \u2192 slow_fill_pct > 10%\n--   2. Is a new chain's filler infrastructure mature? \u2192 Compare p95_ttf\n--   3. Where should we prioritize filler incentives? \u2192 liquidity_gap_status = 'HIGH'\n-- ============================================================================\n\n\n\nWITH base_data AS (\n    SELECT\n        *,\n        DATE_TRUNC('minute', deposit_timestamp) AS deposit_minute\n    FROM \"across_analytics\".\"dbt_intermediate\".\"int_deposit_fill_matching\"\n),\n\n-- Chain name mapping\nchain_names AS (\n    SELECT \n        chain_id,\n        chain_name\n    FROM (VALUES\n        (1, 'Ethereum'),\n        (42161, 'Arbitrum'),\n        (137, 'Polygon'),\n        (59144, 'Linea'),\n        (480, 'Worldchain'),\n        (130, 'Unichain'),\n        (999, 'HyperEVM'),\n        (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Token metadata for symbol lookup\ntoken_metadata AS (\n    SELECT * FROM \"across_analytics\".\"dbt\".\"token_metadata\"\n),\n\n-- Aggregate by hour, route, and token\nhourly_latency_metrics AS (\n    SELECT\n        deposit_minute,\n        origin_chain_id,\n        destination_chain_id,\n        route_id,\n        deposit_token,\n        \n        -- === VOLUME METRICS ===\n        COUNT(*) AS total_deposits,\n        SUM(CASE WHEN is_filled THEN 1 ELSE 0 END) AS total_fills,\n        SUM(CASE WHEN NOT is_filled THEN 1 ELSE 0 END) AS unfilled_count,\n        \n        -- Fill rate\n        ROUND(\n            (SUM(CASE WHEN is_filled THEN 1 ELSE 0 END)::NUMERIC / NULLIF(COUNT(*), 0)) * 100, \n            2\n        ) AS fill_rate_pct,\n        \n        -- === LATENCY DISTRIBUTION ===\n        -- Core TTF metrics (only for filled deposits)\n        ROUND(AVG(CASE WHEN is_filled THEN fill_latency_seconds END)::NUMERIC, 2) AS avg_ttf_seconds,\n        ROUND(\n            PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY fill_latency_seconds) \n            FILTER (WHERE is_filled)::NUMERIC, \n            2\n        ) AS median_ttf_seconds,\n        ROUND(\n            PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY fill_latency_seconds) \n            FILTER (WHERE is_filled)::NUMERIC, \n            2\n        ) AS p95_ttf_seconds,\n        MIN(CASE WHEN is_filled THEN fill_latency_seconds END) AS min_ttf_seconds,\n        MAX(CASE WHEN is_filled THEN fill_latency_seconds END) AS max_ttf_seconds,\n        \n        -- === SPEED BUCKET COUNTS ===\n        -- Instant fills (\u226430 seconds) - \"Lightning fast\"\n        SUM(CASE WHEN is_filled AND fill_latency_seconds <= 30 THEN 1 ELSE 0 END) AS instant_fill_count,\n        \n        -- Fast fills (\u226460 seconds)\n        SUM(CASE WHEN is_filled AND fill_latency_seconds <= 60 THEN 1 ELSE 0 END) AS fast_fill_count,\n        \n        -- Slow fills (>300 seconds / 5 minutes) - \"Filler Hesitation\"\n        SUM(CASE WHEN is_filled AND fill_latency_seconds > 300 THEN 1 ELSE 0 END) AS slow_fill_count,\n        \n        -- Very slow fills (>900 seconds / 15 minutes) - \"Critical Delay\"\n        SUM(CASE WHEN is_filled AND fill_latency_seconds > 900 THEN 1 ELSE 0 END) AS very_slow_fill_count,\n        \n        -- === VOLUME CONTEXT ===\n        SUM(deposit_amount_usd) AS total_deposit_volume_usd,\n        SUM(CASE WHEN is_filled THEN fill_amount_usd ELSE 0 END) AS total_filled_volume_usd,\n        \n        -- === PARTICIPANT METRICS ===\n        COUNT(DISTINCT relayer_address) FILTER (WHERE is_filled) AS unique_relayers\n        \n    FROM base_data\n    GROUP BY \n        deposit_minute,\n        origin_chain_id,\n        destination_chain_id,\n        route_id,\n        deposit_token\n),\n\n-- ============================================================================\n-- COMPUTED INSIGHTS CTE\n-- ============================================================================\n-- PURPOSE: Transform raw counts into actionable percentages and categorical \n--          labels that can be used directly in Superset filters and alerts.\n-- ============================================================================\nwith_insights AS (\n    SELECT\n        *,\n        \n        -- ========================================================================\n        -- INSTANT FILL PERCENTAGE\n        -- ========================================================================\n        -- WHAT: % of fills completed in \u226430 seconds\n        -- WHY:  Measures \"lightning fast\" user experience. High % = excellent UX.\n        --       Across's competitive advantage is speed - this proves it.\n        -- USE:  Dashboard KPI, compare across routes to find speed champions.\n        -- ========================================================================\n        ROUND(\n            (instant_fill_count::NUMERIC / NULLIF(total_fills, 0)) * 100, \n            2\n        ) AS instant_fill_pct,\n        \n        -- ========================================================================\n        -- FAST FILL PERCENTAGE\n        -- ========================================================================\n        -- WHAT: % of fills completed in \u226460 seconds (includes instant fills)\n        -- WHY:  Broader \"good experience\" threshold. Users generally don't \n        --       notice delays under 1 minute. Target: >90% for healthy routes.\n        -- USE:  Route health monitoring, alerting if drops below threshold.\n        -- ========================================================================\n        ROUND(\n            (fast_fill_count::NUMERIC / NULLIF(total_fills, 0)) * 100, \n            2\n        ) AS fast_fill_pct,\n        \n        -- ========================================================================\n        -- SLOW FILL PERCENTAGE (\"Filler Hesitation\" Indicator)\n        -- ========================================================================\n        -- WHAT: % of fills taking >5 minutes (300 seconds)\n        -- WHY:  5+ minute waits indicate fillers are HESITATING to fill this route.\n        --       Causes: low liquidity, high risk perception, poor RPC, or \n        --       unfavorable economics on that destination chain.\n        -- USE:  Alert trigger (>10% = investigate), filler incentive prioritization.\n        -- ========================================================================\n        ROUND(\n            (slow_fill_count::NUMERIC / NULLIF(total_fills, 0)) * 100, \n            2\n        ) AS slow_fill_pct,\n        \n        -- ========================================================================\n        -- VERY SLOW FILL PERCENTAGE (\"Critical Delay\" Indicator)\n        -- ========================================================================\n        -- WHAT: % of fills taking >15 minutes (900 seconds)\n        -- WHY:  15+ minute waits are CRITICAL failures. Users likely abandoned\n        --       or contacted support. These routes need immediate attention.\n        -- USE:  High-priority alert, escalation to engineering team.\n        -- ========================================================================\n        ROUND(\n            (very_slow_fill_count::NUMERIC / NULLIF(total_fills, 0)) * 100, \n            2\n        ) AS very_slow_fill_pct,\n        \n        -- ========================================================================\n        -- LIQUIDITY GAP STATUS (Categorical Health Label)\n        -- ========================================================================\n        -- WHAT: Classifies each hourly observation as CRITICAL / HIGH / MODERATE / HEALTHY \n        --       based on the p95 TTF for that hour-route-token combination.\n        -- WHY:  Provides a simple filter in Superset: \"Show me all CRITICAL gap routes\"\n        --       The p95 is used (not avg) because we care about WORST-CASE experience.\n        -- \n        -- DATA-DRIVEN THRESHOLDS (based on actual distribution from dataset):\n        --   Raw fill latencies (all users): median=8s, p75=15s, p95=42s\n        --   Route-level p95s: median=10.5s, p75=24s, p95=96s\n        --\n        --   - CRITICAL: > 100s  \u2192 Route's worst 5% is 2.5x slower than global worst 5%\n        --   - HIGH:     30-100s \u2192 Route's worst 5% exceeds global p95 (42s), investigate\n        --   - MODERATE: 15-30s  \u2192 Route's worst 5% is typical to slightly slow\n        --   - HEALTHY:  < 15s   \u2192 Route's worst 5% beats global p75 (15s), excellent UX\n        --\n        -- USE:  Superset filter, executive summary, filler incentive targeting.\n        -- ========================================================================\n        CASE \n            WHEN p95_ttf_seconds > 100 THEN 'CRITICAL'\n            WHEN p95_ttf_seconds > 30 THEN 'HIGH'\n            WHEN p95_ttf_seconds > 15 THEN 'MODERATE'\n            ELSE 'HEALTHY'\n        END AS liquidity_gap_status\n        \n    FROM hourly_latency_metrics\n)\n\nSELECT\n    -- Time dimension\n    wi.deposit_minute,\n    \n    -- Route identifiers with human-readable names\n    wi.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    wi.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    wi.route_id,\n    oc.chain_name || ' \u2192 ' || dc.chain_name AS route_name,\n    \n    -- Token info\n    wi.deposit_token,\n    tm.token_symbol,\n    CASE \n        WHEN tm.token_symbol LIKE 'USDC%' THEN 'USDC'\n        WHEN tm.token_symbol LIKE 'USDT%' THEN 'USDT'\n        WHEN tm.token_symbol LIKE 'DAI%' THEN 'DAI'\n        WHEN tm.token_symbol LIKE 'WETH%' THEN 'WETH'\n        WHEN tm.token_symbol LIKE 'WBTC%' THEN 'WBTC'\n        ELSE tm.token_symbol\n    END AS base_token_symbol,\n    \n    -- Volume metrics\n    wi.total_deposits,\n    wi.total_fills,\n    wi.unfilled_count,\n    wi.fill_rate_pct,\n    wi.total_deposit_volume_usd,\n    wi.total_filled_volume_usd,\n    \n    -- Latency distribution\n    wi.avg_ttf_seconds,\n    wi.median_ttf_seconds,\n    wi.p95_ttf_seconds,\n    wi.min_ttf_seconds,\n    wi.max_ttf_seconds,\n    \n    -- Speed bucket counts\n    wi.instant_fill_count,\n    wi.fast_fill_count,\n    wi.slow_fill_count,\n    wi.very_slow_fill_count,\n    \n    -- Speed bucket percentages\n    wi.instant_fill_pct,\n    wi.fast_fill_pct,\n    wi.slow_fill_pct,\n    wi.very_slow_fill_pct,\n    \n    -- Computed insights\n    wi.liquidity_gap_status,\n    \n    -- Participant metrics\n    wi.unique_relayers\n\nFROM with_insights wi\nLEFT JOIN chain_names oc ON wi.origin_chain_id = oc.chain_id\nLEFT JOIN chain_names dc ON wi.destination_chain_id = dc.chain_id\nLEFT JOIN token_metadata tm ON wi.origin_chain_id = tm.chain_id \n    AND LOWER(wi.deposit_token) = LOWER(tm.token_address)\n\nORDER BY wi.deposit_minute DESC, wi.total_deposit_volume_usd DESC", "relation_name": "\"across_analytics\".\"dbt_marts\".\"mart_fill_latency_analysis\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-07T16:44:25.807915Z", "completed_at": "2026-01-07T16:44:25.857266Z"}, {"name": "execute", "started_at": "2026-01-07T16:44:25.860177Z", "completed_at": "2026-01-07T16:44:26.523435Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.7765967845916748, "adapter_response": {"_message": "SELECT 3760", "code": "SELECT", "rows_affected": 3760}, "message": "SELECT 3760", "failures": null, "unique_id": "model.across_analytics.mart_general_overview", "compiled": true, "compiled_code": "-- mart_general_overview.sql\n-- PURPOSE: High-level protocol overview for the main Superset dashboard\n-- GRAIN: Minute \u00d7 Origin Chain \u00d7 Destination Chain \u00d7 Token\n-- WHY: Provides general metrics with drill-down capability for flexible Superset filtering\n\n\n\nWITH base_data AS (\n    SELECT\n        *,\n        DATE_TRUNC('minute', deposit_timestamp) AS deposit_minute\n    FROM \"across_analytics\".\"dbt_intermediate\".\"int_deposit_fill_matching\"\n),\n\n-- Chain name mapping\nchain_names AS (\n    SELECT \n        chain_id,\n        chain_name\n    FROM (VALUES\n        (1, 'Ethereum'),\n        (42161, 'Arbitrum'),\n        (137, 'Polygon'),\n        (59144, 'Linea'),\n        (480, 'Worldchain'),\n        (130, 'Unichain'),\n        (999, 'HyperEVM'),\n        (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Token metadata for symbol lookup\ntoken_metadata AS (\n    SELECT * FROM \"across_analytics\".\"dbt\".\"token_metadata\"\n),\n\n-- Aggregate by hour, route, and token\nhourly_metrics AS (\n    SELECT\n        deposit_minute,\n        origin_chain_id,\n        destination_chain_id,\n        route_id,\n        deposit_token,\n        \n        -- === VOLUME METRICS ===\n        -- Transaction counts\n        COUNT(*) AS total_deposits,\n        SUM(CASE WHEN is_filled THEN 1 ELSE 0 END) AS total_fills,\n        \n        -- Volume in native token units\n        SUM(deposit_amount) AS total_deposit_volume,\n        SUM(CASE WHEN is_filled THEN actual_output_amount ELSE 0 END) AS total_filled_volume,\n        \n        -- Volume in USD\n        SUM(deposit_amount_usd) AS total_deposit_volume_usd,\n        SUM(CASE WHEN is_filled THEN fill_amount_usd ELSE 0 END) AS total_filled_volume_usd,\n        \n        -- === ACTIVITY METRICS ===\n        COUNT(DISTINCT depositor_address) AS unique_depositors,\n        COUNT(DISTINCT relayer_address) FILTER (WHERE is_filled) AS unique_relayers,\n        \n        -- === PERFORMANCE SNAPSHOT (summary only) ===\n        -- Fill rate\n        ROUND((SUM(CASE WHEN is_filled THEN 1 ELSE 0 END)::NUMERIC / NULLIF(COUNT(*), 0)) * 100, 2) AS fill_rate_pct,\n        \n        -- Latency summary (just avg and median for overview)\n        ROUND(AVG(CASE WHEN is_filled THEN fill_latency_seconds END)::NUMERIC, 2) AS avg_fill_latency_seconds,\n        ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY fill_latency_seconds) FILTER (WHERE is_filled)::NUMERIC, 2) AS median_fill_latency_seconds,\n        \n        -- === ECONOMIC SNAPSHOT (summary only) ===\n        -- Total fees collected\n        SUM(CASE WHEN is_filled THEN bridge_fee_nominal ELSE 0 END) AS total_bridge_fees,\n        \n        -- Average fee percentage\n        ROUND(AVG(CASE WHEN is_filled THEN bridge_fee_percent END)::NUMERIC, 4) AS avg_bridge_fee_pct,\n        \n        -- Average slippage\n        ROUND(AVG(CASE WHEN is_filled THEN slippage_percent END)::NUMERIC, 4) AS avg_slippage_pct\n        \n    FROM base_data\n    GROUP BY \n        deposit_minute,\n        origin_chain_id,\n        destination_chain_id,\n        route_id,\n        deposit_token\n)\n\nSELECT\n    -- Time dimension\n    hm.deposit_minute,\n    \n    -- Route identifiers with human-readable names\n    hm.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    hm.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    hm.route_id,\n    oc.chain_name || ' \u2192 ' || dc.chain_name AS route_name,\n    \n    -- Token info\n    hm.deposit_token,\n    tm.token_symbol,\n    -- handle token symbol for base token as USDC.e and USDC.bridged are the same, etc.\n    CASE \n        WHEN token_symbol LIKE 'USDC%' THEN 'USDC'\n        WHEN token_symbol LIKE 'USDT%' THEN 'USDT'\n        WHEN token_symbol LIKE 'DAI%' THEN 'DAI'\n        WHEN token_symbol LIKE 'WETH%' THEN 'WETH'\n        WHEN token_symbol LIKE 'WBTC%' THEN 'WBTC'\n    ELSE token_symbol\n    END AS base_token_symbol,\n    \n    -- Volume metrics\n    hm.total_deposits,\n    hm.total_fills,\n    hm.total_deposit_volume,\n    hm.total_filled_volume,\n    hm.total_deposit_volume_usd,\n    hm.total_filled_volume_usd,\n    \n    -- Activity metrics\n    hm.unique_depositors,\n    hm.unique_relayers,\n    \n    -- Performance snapshot\n    hm.fill_rate_pct,\n    hm.avg_fill_latency_seconds,\n    hm.median_fill_latency_seconds,\n    \n    -- Economic snapshot\n    hm.total_bridge_fees,\n    hm.avg_bridge_fee_pct,\n    hm.avg_slippage_pct\n\nFROM hourly_metrics hm\nLEFT JOIN chain_names oc ON hm.origin_chain_id = oc.chain_id\nLEFT JOIN chain_names dc ON hm.destination_chain_id = dc.chain_id\nLEFT JOIN token_metadata tm ON hm.origin_chain_id = tm.chain_id \n    AND LOWER(hm.deposit_token) = LOWER(tm.token_address)\n\nORDER BY hm.deposit_minute DESC, hm.total_deposit_volume_usd DESC", "relation_name": "\"across_analytics\".\"dbt_marts\".\"mart_general_overview\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-07T16:44:25.777352Z", "completed_at": "2026-01-07T16:44:25.836064Z"}, {"name": "execute", "started_at": "2026-01-07T16:44:25.844846Z", "completed_at": "2026-01-07T16:44:26.610929Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.8664398193359375, "adapter_response": {"_message": "SELECT 3710", "code": "SELECT", "rows_affected": 3710}, "message": "SELECT 3710", "failures": null, "unique_id": "model.across_analytics.mart_bridge_fee_analysis", "compiled": true, "compiled_code": "-- ============================================================================\n-- mart_bridge_fee_analysis.sql\n-- ============================================================================\n-- PURPOSE: Analyze bridge fees to identify over-priced corridors and \n--          inform competitive pricing strategy\n-- \n-- GRAIN: Minute \u00d7 Route \u00d7 Token\n-- \n-- KEY INSIGHT: bridge_fee_nominal = deposit_amount - actual_output_amount\n--              This already includes ALL user costs: gas + relayer + bridge + slippage\n-- \n-- KEY BUSINESS QUESTIONS:\n--   1. Which corridors are overpriced? \u2192 effective_fee_pct comparison\n--   2. ETH\u2192Unichain vs ETH\u2192Optimism fee comparison \u2192 Filter by origin, group by destination\n--   3. Where are users paying the most? \u2192 Sort by effective_fee_pct DESC\n-- ============================================================================\n\n\n\nWITH base_data AS (\n    SELECT\n        *,\n        DATE_TRUNC('minute', deposit_timestamp) AS deposit_minute\n    FROM \"across_analytics\".\"dbt_intermediate\".\"int_deposit_fill_matching\"\n    WHERE is_filled = TRUE  -- Only filled deposits have fee data\n),\n\n-- Chain name mapping\nchain_names AS (\n    SELECT \n        chain_id,\n        chain_name\n    FROM (VALUES\n        (1, 'Ethereum'),\n        (42161, 'Arbitrum'),\n        (137, 'Polygon'),\n        (59144, 'Linea'),\n        (480, 'Worldchain'),\n        (130, 'Unichain'),\n        (999, 'HyperEVM'),\n        (143, 'Monad')\n    ) AS chains(chain_id, chain_name)\n),\n\n-- Token metadata for symbol lookup\ntoken_metadata AS (\n    SELECT * FROM \"across_analytics\".\"dbt\".\"token_metadata\"\n),\n\n-- ============================================================================\n-- HOURLY FEE METRICS CTE\n-- ============================================================================\n-- PURPOSE: Aggregate fee-related metrics by hour, route, and token.\n--          All fee calculations are in USD for cross-token comparability.\n-- ============================================================================\nhourly_fee_metrics AS (\n    SELECT\n        deposit_minute,\n        origin_chain_id,\n        destination_chain_id,\n        route_id,\n        deposit_token,\n        \n        -- ========================================================================\n        -- VOLUME METRICS\n        -- ========================================================================\n        -- WHAT: Count of filled transactions and USD volume\n        -- WHY:  Provides context for fee metrics. A route with $10M volume and\n        --       0.3% fee is more important than $10K volume with 0.1% fee.\n        -- USE:  Weight fee analysis by volume, filter out low-activity routes.\n        -- ========================================================================\n        COUNT(*) AS total_fills,\n        SUM(deposit_amount_usd) AS total_deposit_volume_usd,\n        SUM(fill_amount_usd) AS total_filled_volume_usd,\n        \n        -- ========================================================================\n        -- TOTAL FEES (USD)\n        -- ========================================================================\n        -- WHAT: Sum of all fees collected on this route, converted to USD\n        -- WHY:  bridge_fee_nominal = deposit_amount - actual_output_amount\n        --       This is the ALL-IN user cost including gas, relayer, and protocol fees.\n        -- USE:  Revenue analysis, compare fee revenue across routes.\n        -- ========================================================================\n        SUM(bridge_fee_nominal * COALESCE(deposit_token_price_usd, 1)) AS total_fees_usd,\n        \n        -- ========================================================================\n        -- EFFECTIVE FEE PERCENTAGE (Core Metric)\n        -- ========================================================================\n        -- WHAT: Total fees / Total volume \u00d7 100 (volume-weighted average fee)\n        -- WHY:  This is the TRUE cost per dollar bridged. Unlike avg_fee_pct,\n        --       this weights large transactions more heavily (as they should be).\n        --       Example: 10 small txns at 0.5% + 1 large txn at 0.1% \u2192 effective < 0.5%\n        -- USE:  Primary metric for corridor pricing comparison. Target: <0.3%.\n        -- ========================================================================\n        ROUND(\n            ((SUM(bridge_fee_nominal * COALESCE(deposit_token_price_usd, 1)) / \n             NULLIF(SUM(deposit_amount_usd), 0)) * 100)::NUMERIC, 4) \n        AS effective_fee_pct,\n        \n        -- ========================================================================\n        -- AVERAGE FEE PERCENTAGE\n        -- ========================================================================\n        -- WHAT: Simple arithmetic mean of fee % across all transactions\n        -- WHY:  Treats all transactions equally. Useful for understanding \"typical\"\n        --       user experience regardless of transaction size.\n        -- USE:  Compare with effective_fee_pct; big difference = size disparity.\n        -- ========================================================================\n        ROUND(AVG(bridge_fee_percent)::NUMERIC, 4) AS avg_fee_pct,\n        \n        -- ========================================================================\n        -- MEDIAN FEE PERCENTAGE\n        -- ========================================================================\n        -- WHAT: 50th percentile of fee % (half of txns pay more, half pay less)\n        -- WHY:  More robust than avg to outliers. If median << avg, there are\n        --       some transactions with unusually high fees (investigate why).\n        -- USE:  Robust \"typical\" fee, outlier detection when compared to avg.\n        -- ========================================================================\n        ROUND(\n            PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY bridge_fee_percent)::NUMERIC, \n            4\n        ) AS median_fee_pct,\n        \n        -- ========================================================================\n        -- FEE STANDARD DEVIATION\n        -- ========================================================================\n        -- WHAT: How much fee % varies across transactions\n        -- WHY:  High std dev = unpredictable pricing for users. Users prefer\n        --       consistent fees. High volatility may indicate dynamic pricing\n        --       issues or liquidity fluctuations.\n        -- USE:  Stability indicator, alerting on high volatility routes.\n        -- ========================================================================\n        ROUND(STDDEV(bridge_fee_percent)::NUMERIC, 4) AS fee_std_dev,\n        \n        -- ========================================================================\n        -- MIN/MAX FEE PERCENTAGE\n        -- ========================================================================\n        -- WHAT: Best and worst fee % observed on this route\n        -- WHY:  Shows the full range of user experience. Large spread indicates\n        --       inconsistent pricing that confuses users.\n        -- USE:  Outlier investigation, competitive analysis (\"best rate we offer\").\n        -- ========================================================================\n        ROUND(MIN(bridge_fee_percent)::NUMERIC, 4) AS min_fee_pct,\n        ROUND(MAX(bridge_fee_percent)::NUMERIC, 4) AS max_fee_pct,\n        \n        -- ========================================================================\n        -- SLIPPAGE METRICS (Transparency, Not Cost)\n        -- ========================================================================\n        -- WHAT: Difference between expected_output and actual_output as %\n        -- WHY:  Slippage is ALREADY INCLUDED in bridge_fee_nominal. We show it\n        --       separately for transparency: how much of the fee is \"predictable\"\n        --       vs \"market movement\".\n        -- NOTE: Positive slippage = user got less than expected (bad)\n        --       Negative slippage = user got more than expected (rare, good)\n        -- USE:  Transparency reporting, not for cost calculation.\n        -- ========================================================================\n        ROUND(AVG(slippage_percent)::NUMERIC, 4) AS avg_slippage_pct,\n        ROUND(\n            PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY slippage_percent)::NUMERIC, \n            4\n        ) AS median_slippage_pct,\n        \n        -- ========================================================================\n        -- PARTICIPANT METRICS\n        -- ========================================================================\n        -- WHAT: Count of unique users and relayers on this route\n        -- WHY:  High depositor count = popular route (user demand).\n        --       High relayer count = competitive filling (healthy supply).\n        --       Low relayer count + high volume = relayer concentration risk.\n        -- USE:  Market health assessment, relayer diversity monitoring.\n        -- ========================================================================\n        COUNT(DISTINCT depositor_address) AS unique_depositors,\n        COUNT(DISTINCT relayer_address) AS unique_relayers,\n        \n        -- ========================================================================\n        -- GAS COST METRICS (Relayer Cost Analysis)\n        -- ========================================================================\n        -- WHAT: Gas price and cost metrics for relayer fills\n        -- WHY:  Gas costs are incurred by RELAYERS on the destination chain.\n        --       High gas costs may:\n        --       - Reduce relayer profitability \u2192 fewer fillers \u2192 slower fills\n        --       - Force higher bridge fees to remain profitable\n        --       - Explain fee volatility on certain corridors\n        -- USE:  Relayer economics analysis, corridor cost comparison, fee justification.\n        -- ========================================================================\n        -- ========================================================================\n        -- Average gas price in Gwei (wei / 10^9)\n        -- NOTE: Cast to NUMERIC before aggregation to prevent bigint overflow\n        ROUND((AVG(gas_price_wei::NUMERIC) / 1e9)::NUMERIC, 4) AS avg_gas_price_gwei,\n        \n        -- Median gas price in Gwei (more robust than average)\n        ROUND(\n            (PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY gas_price_wei::NUMERIC) / 1e9)::NUMERIC, \n            4\n        ) AS median_gas_price_gwei,\n        \n        -- Total gas cost in native token (sum of all relayer gas costs)\n        -- NOTE: Different chains use different native tokens (ETH, MATIC, WLD, etc.)\n        -- NOTE: Cast to NUMERIC before aggregation to prevent bigint overflow\n        ROUND((SUM(gas_cost_wei::NUMERIC) / 1e18)::NUMERIC, 8) AS total_gas_cost_native,\n        \n        -- Average gas cost per fill in native token\n        ROUND((AVG(gas_cost_wei::NUMERIC) / 1e18)::NUMERIC, 8) AS avg_gas_cost_native,\n        \n        -- ========================================================================\n        -- GAS COST IN USD (Cross-Chain Comparable)\n        -- ========================================================================\n        -- WHAT: Gas costs converted to USD using native token price at fill time\n        -- WHY:  Native token costs aren't comparable across chains (0.001 ETH \u2260 0.001 MATIC).\n        --       USD conversion enables:\n        --       - Cross-chain gas cost comparison\n        --       - Total relayer operational cost analysis\n        --       - Fee vs gas cost ratio calculations\n        -- USE:  Relayer profitability analysis, corridor cost benchmarking.\n        -- ========================================================================\n        ROUND(SUM(gas_cost_usd)::NUMERIC, 2) AS total_gas_cost_usd,\n        ROUND(AVG(gas_cost_usd)::NUMERIC, 4) AS avg_gas_cost_usd\n        \n    FROM base_data\n    GROUP BY \n        deposit_minute,\n        origin_chain_id,\n        destination_chain_id,\n        route_id,\n        deposit_token\n),\n\n-- ============================================================================\n-- COMPUTED INSIGHTS CTE\n-- ============================================================================\n-- PURPOSE: Transform numeric metrics into categorical labels for easy\n--          Superset filtering, alerting, and executive reporting.\n-- ============================================================================\nwith_insights AS (\n    SELECT\n        *,\n        \n        -- ========================================================================\n        -- PRICING TIER (Categorical Competitive Position)\n        -- ========================================================================\n        -- WHAT: Classifies route as OVERPRICED / HIGH / COMPETITIVE / AGGRESSIVE / VERY_LOW\n        -- WHY:  Enables quick identification of routes where Across may be\n        --       losing users to competitors (OVERPRICED) or leaving money on\n        --       the table (VERY_LOW).\n        --\n        -- DATA-DRIVEN THRESHOLDS (based on actual distribution from dataset):\n        --   Distribution: median=0.0135%, p75=0.056%, p95=0.37%, p99=2.15%\n        --\n        --   - OVERPRICED:   > 0.5%    \u2192 True outliers (~5% of data), investigate\n        --   - HIGH:         0.1-0.5%  \u2192 Above p75, higher than typical (~15%)\n        --   - COMPETITIVE:  0.02-0.1% \u2192 Around median, market rate (~30-40%)\n        --   - AGGRESSIVE:   0.005-0.02% \u2192 Below median, undercutting (~20-30%)\n        --   - VERY_LOW:     < 0.005%  \u2192 Near-zero fees, possibly subsidized (~15%)\n        --\n        -- USE:  Superset filter \"Show OVERPRICED routes\", pricing strategy review.\n        -- ========================================================================\n        CASE \n            WHEN effective_fee_pct > 0.5 THEN 'OVERPRICED'\n            WHEN effective_fee_pct > 0.1 THEN 'HIGH'\n            WHEN effective_fee_pct > 0.02 THEN 'COMPETITIVE'\n            WHEN effective_fee_pct > 0.005 THEN 'AGGRESSIVE'\n            ELSE 'VERY_LOW'\n        END AS pricing_tier,\n        \n        -- ========================================================================\n        -- FEE VOLATILITY TIER (Pricing Stability)\n        -- ========================================================================\n        -- WHAT: Classifies fee consistency as HIGH_VOLATILITY / MODERATE / LOW / STABLE\n        -- WHY:  Users prefer predictable fees. High volatility indicates:\n        --       - Dynamic pricing swings (may be correct but confusing)\n        --       - Liquidity issues causing fee spikes\n        --       - Inconsistent relayer behavior\n        --\n        -- DATA-DRIVEN THRESHOLDS (based on actual distribution from dataset):\n        --   Distribution: median=0.057, p75=0.36, p95=1.68, p99=8.28\n        --\n        --   - HIGH_VOLATILITY:     > 1.0   \u2192 True outliers (~10%), investigate\n        --   - MODERATE_VOLATILITY: 0.3-1.0 \u2192 Above p75, notable variation (~15-20%)\n        --   - LOW_VOLATILITY:      0.05-0.3 \u2192 Around median, acceptable (~40-50%)\n        --   - STABLE:              < 0.05  \u2192 Below median, consistent pricing (~25%)\n        --\n        -- USE:  Alert on HIGH_VOLATILITY routes, UX improvement targeting.\n        -- ========================================================================\n        CASE \n            WHEN fee_std_dev > 1.0 THEN 'HIGH_VOLATILITY'\n            WHEN fee_std_dev > 0.3 THEN 'MODERATE_VOLATILITY'\n            WHEN fee_std_dev > 0.05 THEN 'LOW_VOLATILITY'\n            ELSE 'STABLE'\n        END AS fee_volatility_tier,\n        \n        -- ========================================================================\n        -- FEE SPREAD (Range Indicator)\n        -- ========================================================================\n        -- WHAT: max_fee_pct - min_fee_pct (width of fee range)\n        -- WHY:  Complements std_dev with a simpler measure. Large spread means\n        --       some users got great rates while others got terrible rates.\n        --       Example: min=0.1%, max=1.0% \u2192 spread=0.9% (very inconsistent!)\n        -- USE:  Fairness analysis, identify routes with extreme outliers.\n        -- ========================================================================\n        ROUND((max_fee_pct - min_fee_pct)::NUMERIC, 4) AS fee_spread_pct,\n        \n        -- ========================================================================\n        -- GAS COST TIER (Relayer Economics)\n        -- ========================================================================\n        -- WHAT: Classifies corridors by gas cost level\n        -- WHY:  High gas costs affect relayer profitability and may explain:\n        --       - Higher bridge fees on certain routes\n        --       - Fewer relayers willing to fill (leading to slower fills)\n        --       - Corridors that need optimization\n        --\n        -- DATA-DRIVEN THRESHOLDS (based on actual distribution from dataset):\n        --   Distribution: median=0.00001, p75=0.00016, p95=0.067, p99=0.19\n        --\n        --   - VERY_HIGH: > 0.05 native   \u2192 Top ~5%, expensive corridors\n        --   - HIGH:      0.001-0.05      \u2192 Above p75, notable cost (~10-15%)\n        --   - MEDIUM:    0.0001-0.001    \u2192 Around p75, moderate (~15-20%)\n        --   - LOW:       0.00001-0.0001  \u2192 Around median (~30-40%)\n        --   - VERY_LOW:  < 0.00001       \u2192 Below median, very cheap (~25%)\n        --\n        -- USE:  Corridor optimization, relayer incentive analysis.\n        -- ========================================================================\n        CASE \n            WHEN avg_gas_cost_native > 0.05 THEN 'VERY_HIGH'\n            WHEN avg_gas_cost_native > 0.001 THEN 'HIGH'\n            WHEN avg_gas_cost_native > 0.0001 THEN 'MEDIUM'\n            WHEN avg_gas_cost_native > 0.00001 THEN 'LOW'\n            ELSE 'VERY_LOW'\n        END AS gas_cost_tier\n        \n    FROM hourly_fee_metrics\n)\n\nSELECT\n    -- Time dimension\n    wi.deposit_minute,\n    \n    -- Route identifiers with human-readable names\n    wi.origin_chain_id,\n    oc.chain_name AS origin_chain_name,\n    wi.destination_chain_id,\n    dc.chain_name AS destination_chain_name,\n    wi.route_id,\n    oc.chain_name || ' \u2192 ' || dc.chain_name AS route_name,\n    \n    -- Token info\n    wi.deposit_token,\n    tm.token_symbol,\n    CASE \n        WHEN tm.token_symbol LIKE 'USDC%' THEN 'USDC'\n        WHEN tm.token_symbol LIKE 'USDT%' THEN 'USDT'\n        WHEN tm.token_symbol LIKE 'DAI%' THEN 'DAI'\n        WHEN tm.token_symbol LIKE 'WETH%' THEN 'WETH'\n        WHEN tm.token_symbol LIKE 'WBTC%' THEN 'WBTC'\n        ELSE tm.token_symbol\n    END AS base_token_symbol,\n    \n    -- Volume metrics\n    wi.total_fills,\n    wi.total_deposit_volume_usd,\n    wi.total_filled_volume_usd,\n    \n    -- Fee metrics (USD)\n    wi.total_fees_usd,\n    wi.effective_fee_pct,\n    \n    -- Fee distribution\n    wi.avg_fee_pct,\n    wi.median_fee_pct,\n    wi.fee_std_dev,\n    wi.min_fee_pct,\n    wi.max_fee_pct,\n    wi.fee_spread_pct,\n    \n    -- Slippage (for transparency)\n    wi.avg_slippage_pct,\n    wi.median_slippage_pct,\n    \n    -- Computed insights\n    wi.pricing_tier,\n    wi.fee_volatility_tier,\n    \n    -- Participant metrics\n    wi.unique_depositors,\n    wi.unique_relayers,\n    \n    -- Gas cost metrics (relayer economics)\n    wi.avg_gas_price_gwei,\n    wi.median_gas_price_gwei,\n    wi.total_gas_cost_native,\n    wi.avg_gas_cost_native,\n    wi.total_gas_cost_usd,\n    wi.avg_gas_cost_usd,\n    wi.gas_cost_tier\n\nFROM with_insights wi\nLEFT JOIN chain_names oc ON wi.origin_chain_id = oc.chain_id\nLEFT JOIN chain_names dc ON wi.destination_chain_id = dc.chain_id\nLEFT JOIN token_metadata tm ON wi.origin_chain_id = tm.chain_id \n    AND LOWER(wi.deposit_token) = LOWER(tm.token_address)\n\nORDER BY wi.deposit_minute DESC, wi.total_deposit_volume_usd DESC", "relation_name": "\"across_analytics\".\"dbt_marts\".\"mart_bridge_fee_analysis\"", "batch_results": null}], "elapsed_time": 4.438898086547852, "args": {"log_path": "C:\\Users\\Longin\\Desktop\\Projects\\across_analytics\\logs", "log_level_file": "debug", "require_resource_names_without_spaces": true, "source_freshness_run_project_hooks": true, "printer_width": 80, "state_modified_compare_more_unrendered_values": false, "state_modified_compare_vars": false, "require_generic_test_arguments_property": true, "skip_nodes_if_on_run_start_fails": false, "partial_parse_file_diff": true, "show_resource_report": false, "strict_mode": false, "print": true, "warn_error_options": {"error": [], "warn": [], "silence": []}, "require_all_warnings_handled_by_warn_error": false, "which": "run", "use_colors": true, "select": ["token_prices+"], "validate_macro_args": false, "log_format_file": "debug", "empty": false, "require_yaml_configuration_for_mf_time_spines": false, "use_fast_test_edges": false, "profiles_dir": "C:\\Users\\Longin\\.dbt", "quiet": false, "vars": {}, "show_all_deprecations": false, "upload_to_artifacts_ingest_api": false, "send_anonymous_usage_stats": true, "version_check": true, "log_level": "info", "exclude": [], "populate_cache": true, "require_batched_execution_for_custom_microbatch_strategy": false, "write_json": true, "defer": false, "macro_debugging": false, "static_parser": true, "require_nested_cumulative_type_params": false, "favor_state": false, "cache_selected_only": false, "log_file_max_bytes": 10485760, "partial_parse": true, "project_dir": "C:\\Users\\Longin\\Desktop\\Projects\\across_analytics", "use_colors_file": true, "introspect": true, "invocation_command": "dbt run --select token_prices+", "require_explicit_package_overrides_for_builtin_materializations": true, "indirect_selection": "eager", "log_format": "default"}}